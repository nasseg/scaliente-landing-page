<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unicorn Studio Animation (Offline)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }

        #unicorn-canvas {
            width: 100vw;
            height: 100vh;
        }

        /* Extra safety CSS */
        a[href*="unicorn.studio"] {
            display: none !important;
        }
    </style>
    <script>
        // EMBEDDED PROJECT DATA (Offline Mode)
        window.__UNICORN_DATA = { "history": [{ "breakpoints": [], "visible": true, "aspectRatio": 1, "userDownsample": 0.25, "layerType": "effect", "type": "gradient", "usesPingPong": false, "speed": 0.36, "trackMouse": 0, "trackAxes": "xy", "mouseMomentum": 0, "texture": false, "animating": true, "isMask": 0, "compiledFragmentShaders": ["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime;\nuniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0.9411764705882353, 0.9411764705882353, 0.9411764705882353);\ncase 3: return vec3(0.7176470588235294, 0.7176470588235294, 0.7176470588235294);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.6031;\ncase 2: return 0.8750;\ncase 3: return 0.9219;\ncase 4: return 1.0000;\ncase 5: return 0.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}float rand(vec2 co) {\nreturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(rgb, vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(lin, vec3(1.0/2.2));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) );\nvec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.025 * a * (1.0-a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nfor (int i = 0; i < 5 - 1; i++) {\nfloat colorPosition = getStop(i);\nfloat nextColorPosition = getStop(i + 1);\nif (position <= nextColorPosition) {\nfloat mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition);\nvec3 linStart = linear_from_srgb(getColor(i));\nvec3 linEnd = linear_from_srgb(getColor(i + 1));\nvec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor);\nreturn srgb_from_linear(mixedLin);\n}\n}\nreturn getColor(5 - 1);\n}out vec4 fragColor;vec3 applyColorToPosition(float position) {\nvec3 color = vec3(0);\nposition -= (uTime * 0.01 + 0.4000);\nfloat cycle = floor(position);\nbool reverse = 0.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos);\nfloat dither = rand(gl_FragCoord.xy) * 0.005;\ncolor += dither;\nreturn color;\n}vec3 radialGrad(vec2 uv) {\nfloat position = length(uv);\nreturn applyColorToPosition(position);\n}vec3 getGradient(vec2 uv) {\nreturn radialGrad(uv);\n}vec3 getColor(vec2 uv) {return getGradient(uv);return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.2600*2.);\nuv = rotate(uv, (0.3915 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"], "compiledVertexShaders": ["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"], "data": { "depth": false, "uniforms": {}, "isBackground": true }, "id": "effect" }, { "breakpoints": [], "visible": true, "aspectRatio": 1, "userDownsample": 0.5, "layerType": "effect", "type": "caustics", "usesPingPong": false, "speed": 0.5, "trackMouse": 0, "trackAxes": "xy", "mouseMomentum": 0, "texture": false, "animating": true, "isMask": 0, "compiledFragmentShaders": ["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}float ease (int easingFunc, float t) {\nreturn t;\n}vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src - dst;\n}const float PI = 3.14159265359;vec4 normalizeNoise(vec4 noise, float amount) {\nreturn mix(noise, (noise + 0.5) * 0.5, amount);\n}mat2 rotate2d(float angle) {\nreturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}vec4 getNoise(vec3 p) {\nvec4 noise = bccNoiseDerivatives_XYBeforeZ(p);\nreturn normalizeNoise(noise, 0.6400);\n}void getCaustics(vec2 uv, out vec4 outNoise, out vec3 outColor) {\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 drift = vec2(0, 0.0000 * uTime * 0.0125);\nvec2 pos = vec2(0.5, 0.5) + drift * rotate2d(0.0000 * -2. * PI);\nfloat mDist = ease(0, max(0.,1. - distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if(0 == 1) {\nmDist = max(0., (0.5 - mDist));\n}uv -= pos;\nuv = uv * aspect * rotate2d(0.0000 * 2. * PI) * vec2(1. - 0.0000, 1.) * 16.0 * 0.3000;float refraction = mix(0.25, 1.3, 0.6600);vec3 p = vec3(uv, uTime * 0.05);\nvec4 noise = getNoise(p);\nvec4 baseNoise = noise;\nvec4 balanceNoise = getNoise(p - vec3(baseNoise.xyz / 32.0) * refraction);\nnoise = getNoise(p - vec3(balanceNoise.xyz / 16.0) * refraction);float balancer = (0.5 + 0.5 * balanceNoise.w);\nfloat normalized = pow(0.5 + 0.5 * noise.w, 2.);\nfloat value = mix(0., normalized + 0.2 * (1.0 - normalized), balancer * mDist);\noutNoise = baseNoise * mDist;\noutColor = vec3(1, 1, 1) * value;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 causticNoise;\nvec3 causticColor;\ngetCaustics(uv, causticNoise, causticColor);\nvec4 color = texture(uTexture, uv + causticNoise.xy * 0.01 * 1.0000);\nif(2 > 0) {\nvec3 blended = blend(2, color.rgb, causticColor);\ncolor.rgb = mix(color.rgb, blended, 1.0000);\n} else {\ncolor.rgb = causticColor * 1.0000;\n}\nfragColor = color;}"], "compiledVertexShaders": ["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"], "data": { "depth": false, "uniforms": {}, "isBackground": false }, "id": "effect1" }, { "breakpoints": [], "visible": true, "aspectRatio": 1, "userDownsample": 0.5, "layerType": "effect", "type": "beam", "usesPingPong": false, "speed": 0.25, "trackMouse": 0, "trackAxes": "xy", "mouseMomentum": 0, "texture": false, "animating": false, "isMask": 0, "compiledFragmentShaders": ["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}vec3 drawViewportEdges(vec2 uv) {\nfloat distToEdge = min(min(uv.x, uv.y), min(1.0 - uv.x, 1.0 - uv.y));\nfloat sdf = distToEdge;\nfloat glowThickness = 0.2300 * 0.8;\nfloat glow = glowThickness / (1.0 - smoothstep(0.12, 0.01, abs(sdf) + 0.02));\nreturn glow * pow(1.0-abs(sdf), 3.0) * vec3(0.27450980392156865, 0.27450980392156865, 0.27450980392156865);\n}vec3 getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawViewportEdges(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(4, Tonemap_tanh(beam), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, luma(beam)));\nfragColor = color;}"], "compiledVertexShaders": ["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"], "data": { "depth": false, "uniforms": {}, "isBackground": false }, "id": "effect2" }, { "breakpoints": [], "visible": true, "aspectRatio": 1, "userDownsample": 0.5, "layerType": "effect", "type": "mouseDraw", "usesPingPong": true, "trackMouse": 0, "trackAxes": "xy", "mouseMomentum": 0.29, "texture": false, "animating": false, "isMask": 0, "compiledFragmentShaders": ["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uPingPongTexture;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb;\nvec3 mouseTrail = rgb2hsv(mouseRgb);\nfloat angle = mouseTrail.x;\nfloat strength = mouseTrail.z * (0.4800 * 5.0);vec2 direction = angleToDir(angle);vec4 bg = texture(uTexture, uv - (direction * 0.1 * strength * 0.3900));\nvec4 color = vec4(0,0,0,1);color.rgb = vec3(strength * mix(mouseRgb, vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333), 1.0000));\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;if(4 > 0) {\nvec3 blendedRgb = blend(4, color.rgb + dither, bg.rgb);\nfragColor = vec4(mix(bg.rgb, blendedRgb, mouseTrail.z), 1.0);\n} else {\nfragColor = mix(bg, color, mouseTrail.z);\n}\n}", "#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.1415926;\nconst float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}vec2 liquify(vec2 st, vec2 dir) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nst.x *= aspectRatio;\nfloat amplitude = 0.0025;\nfloat freq = 6.;\nfor (float i = 1.0; i <= 5.0; i++) {\nst = st * rot(i / 5.0 * PI * 2.0);\nst += vec2(\namplitude * cos(i * freq * st.y + uTime * 0.02 * dir.x),\namplitude * sin(i * freq * st.x + uTime * 0.02 * dir.y)\n);\n}\nst.x /= aspectRatio;\nreturn st;\n}vec3 calculateTrailContribution(vec2 mousePos, vec2 prevMousePos, vec2 uv, vec2 correctedUv, float aspectRatio, float radius) {\nvec2 dir = (mousePos - prevMousePos) * vec2(aspectRatio, 1.0);\nfloat angle = atan(dir.y, dir.x);\nif (angle < 0.0) angle += TWOPI;\nvec2 mouseVec = mousePos - prevMousePos;\nfloat mouseLen = length(mouseVec);\nvec2 mouseDir = mouseLen > 0.0 ? mouseVec / mouseLen : vec2(0.0);\nvec2 posToUv = (correctedUv - prevMousePos) * vec2(aspectRatio, 1.0);\nfloat projection = clamp(dot(posToUv, mouseDir * vec2(aspectRatio, 1.0)), 0.0, mouseLen * aspectRatio);\nvec2 closestPoint = prevMousePos * vec2(aspectRatio, 1.0) + mouseDir * vec2(aspectRatio, 1.0) * projection;\nfloat distanceToLine = distance(correctedUv, closestPoint);\nfloat s = (1.0 + radius)/(distanceToLine + radius) * radius;\nvec3 color = vec3(angle / TWOPI, 1.0, 1.0);\nvec3 pointColor = hsv2rgb(color);\npointColor = pow(pointColor, vec3(2.2));\nfloat intensity = pow(s, 10.0 * (1. - 0.6900 + 0.1));\nreturn pointColor * intensity;\n}void main() {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 uv = vTextureCoord;\nvec2 correctedUv = (uv) * vec2(aspectRatio, 1.0);vec3 lastFrameColor = texture(uPingPongTexture, uv).rgb;\nvec3 lastFrameColorGamma = pow(lastFrameColor, vec3(2.2));\nvec3 hsv = rgb2hsv(lastFrameColor);\nvec3 hsvGamma = rgb2hsv(lastFrameColorGamma);\nvec2 prevDir = angleToDir(hsv.x);\nfloat prevStrength = hsvGamma.z;\nvec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0);\nfloat dist = length(dir);\nfloat blurAmount = 0.03 * prevStrength;\nuv = uv - prevDir * blurAmount;\nuv = mix(uv, liquify(uv - prevDir * 0.005, prevDir), (1. - prevStrength) * 0.7700);\nlastFrameColor = texture(uPingPongTexture, uv).rgb;\nlastFrameColor = pow(lastFrameColor, vec3(2.2));\nint numPoints = int(max(12.0, dist * 24.0));\nfloat speedFactor = clamp(dist, 0.7, 1.3);\nfloat radius = mix(0.1, 0.7, 0.4500 * speedFactor);\nvec3 trailColor = vec3(0.0);\nint iter = min(numPoints, 24);\nfor (int i = 0; i <= iter; i++) {\nfloat t = float(i) / float(numPoints);\nvec2 interpPos = mix(uPreviousMousePos, uMousePos, t);\nvec2 prevInterpPos = i > 0 ? mix(uPreviousMousePos, uMousePos, float(i-1) / float(numPoints)) : uPreviousMousePos;\ntrailColor += calculateTrailContribution(interpPos, prevInterpPos, uv, correctedUv, aspectRatio, radius);\n}\ntrailColor = trailColor / float(min(numPoints, 50) + 1);\nvec3 blurredLastFrame = vec3(0.0);\nfloat clampedDist = clamp(length(trailColor) * dist, 0.0, 1.0);\nfloat blurRadius = 0.005;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(-blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, blurRadius)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, -blurRadius)).rgb, vec3(2.2)) * 0.2;\nblurredLastFrame += lastFrameColor * 0.2;\nblurredLastFrame *= pow(0.9200, 0.2);\nvec3 draw = mix(blurredLastFrame, trailColor, clampedDist);\ndraw = pow(draw, vec3(1.0/2.2));\ndraw.r = max(0.0, draw.r - 0.01);\ndraw.g = max(0.0, draw.g - 0.01);\ndraw.b = max(0.0, draw.b - 0.01);\nfragColor = vec4(draw, 1.0);\n}"], "compiledVertexShaders": ["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}", "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"], "data": { "depth": false, "uniforms": {}, "isBackground": false }, "id": "effect3" }, { "breakpoints": [], "visible": true, "aspectRatio": 1, "userDownsample": 0.5, "layerType": "effect", "type": "circle", "usesPingPong": false, "trackMouse": 0, "trackAxes": "xy", "mouseMomentum": 0, "texture": false, "animating": false, "isMask": 0, "compiledFragmentShaders": ["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src * dst;\n}out vec4 fragColor;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat lum = luma(bg.rgb);\nfloat displacement = (lum - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.4600, 1.0 - 0.4600);\nfloat halfRadius = 0.3040 * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.5, 0.5);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nfalloff = (1.0 - falloff) * 1.0000;\nvec3 circle = vec3(0, 0, 0) * falloff;vec3 blended = blend(3, vec3(0, 0, 0), bg.rgb);\ncircle = mix(bg.rgb, blended, falloff * 1.0000);\nvec4 color = vec4(circle, max(bg.a, falloff));\nfragColor = color;}"], "compiledVertexShaders": ["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"], "data": { "depth": false, "uniforms": {}, "isBackground": false }, "id": "effect4" }, { "breakpoints": [], "visible": true, "aspectRatio": 1, "userDownsample": 0.5, "layerType": "effect", "type": "gradientMap", "usesPingPong": false, "speed": 0.5, "texture": false, "animating": false, "mouseMomentum": 0, "isMask": 0, "compiledFragmentShaders": ["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(1, 0.4196078431372549, 0.20784313725490197);\ncase 3: return vec3(1, 0.4196078431372549, 0.20784313725490197);\ncase 4: return vec3(0.5843137254901961, 0.23921568627450981, 0);\ncase 5: return vec3(0.2901960784313726, 0, 0.20784313725490197);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.2000;\ncase 2: return 0.4000;\ncase 3: return 0.6000;\ncase 4: return 0.8000;\ncase 5: return 1.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}float rand(vec2 co) {\nreturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}vec3 linear_from_srgb(vec3 rgb)\n{\nreturn pow(rgb, vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin)\n{\nreturn pow(lin, vec3(1.0/2.2));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a)\n{\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) );\nvec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.02 * a * (1.0 - a);\nreturn kLMStoCONE*(lms*lms*lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nfor (int i = 0; i < 6 - 1; i++) {\nfloat colorPosition = getStop(i);\nfloat nextColorPosition = getStop(i + 1);\nif (position <= nextColorPosition) {\nfloat mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition);\nvec3 linStart = linear_from_srgb(getColor(i));\nvec3 linEnd = linear_from_srgb(getColor(i + 1));\nvec3 mixedLin = oklab_mix(linStart, linEnd, clamp(mixFactor, 0.0, 1.0));\nreturn srgb_from_linear(mixedLin);\n}\n}\nreturn getColor(6 - 1);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfloat position = smoothstep(0., 1., luma(color.rgb)) * (0.4960 * 2.);\nfloat posOffset = (dot(vec2(0.4824064735008253, 0.49056788312244026).x, vec2(0.4824064735008253, 0.49056788312244026).y) + 0.2300 + 0.0001) * 2.;\nposition -= (uTime*0.01 + posOffset);\nfloat cycle = floor(position);\nbool reverse = 0.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? fract(-position) : fract(position);\nanimatedPos = reverse ? fract(-position) : fract(position);\nanimatedPos = clamp(animatedPos, 0.0, 1.0);vec3 gradientColor = getGradientColor(animatedPos);\nfloat dither = rand(gl_FragCoord.xy) * 0.005;\ngradientColor += dither;\nvec3 mixedColor = mix(color.rgb, gradientColor, 1.0000);color.rgb = mixedColor;\nfragColor = color;\n;\n}"], "compiledVertexShaders": ["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"], "data": { "depth": false, "uniforms": {}, "isBackground": false }, "id": "effect5" }, { "breakpoints": [], "visible": true, "aspectRatio": 1, "userDownsample": 1, "layerType": "effect", "type": "glyphDither", "usesPingPong": false, "texture": { "src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAAoCAYAAADQUaxgAAAOl0lEQVR4Aexdd8wURRR/q2JvKFaMooIFeyeK6KdibEQsqFiIiJVOKH9QQg+9dwjw0XsJhBpaQif0GjqE3nuH77zfwt03Mzt3t7fl7r7lkW/YmTczb97+Zm/fzpuZNzcQUSiooVSpUqFVq1aFjh49Grpy5UpI/JeTkxM6d+5caNOmTaHWrVuHChUqlDYcSpcuHZo1a5Ypjygj4jk5OaEzZ86Eli9fHipTpkxaZMzOzg6tW7dOCuPHj0+5LPny5QutXLlSkqNs2bIplyPW7+WTTz6RZFMxs5PGMxuLv1v6jz/+6Fo+3AP4uJUlUh/P1syZM0NqKFiwoK1+vfXWW0PTp0+X6teoUcNW3YgM8a6ffvqpJ5gBNzV4/eyiX9Q2nKTBJx4mYh4USDgdrL+nnnqKVqxYQRMmTKCXX36Z8ufPTzfcIN+qYRgUfvioSJEiVLt2bdq+fTsdOnQopUAULlyYNm7cSOPGjaOsrCxTHlUAwzDo9ttvp9dee41GjhxJYWVi3pNazq90+KVNv/32GxUtWlQKX3/9Nd1///1+Navle9ttt9Err7wiyVGiRAlt2XQQ33zzTUk2FTM76Xfffdc30YsXL+5aPtwD+HglZPglSh999JEl9OjRw1YTeAZLliwp1S9XrpytunYKvfXWW55gBtzU4PWzi35R23CSBh872KCM/FYFJY8HPIxbtmyhV199Nek7KVCgQNJ1nFYIf9mYyuOZZ55JigWUyRNPPJFUHTeFf/75Z4vyjfD777//IlG+OkGA68RE4MsvvzQ//GIW4IyMQCBQCgQjjUmTJpFhGBZwz549Szt37jRHJvv27aNLly5ZyqSK8P7779OUKVNivphPnTpFGzZsoMOHD1PYjJUqsbTtlC9fXksHEV+PuHK4ioAXfeUFj6vS+Pd/KmSExaBLly7+3YRNzn7eq5+8bd6etlgycgVKgcyYMcNiBjpy5Aj98ssvdMcdd1ChQoXo9ddfp0cffZRuvvlmuu+++6hz58504cIFLZB+EUeNGmVRHjk5ORS23dI999xDd999tzlsfuCBB8xyUDgYVfklTzy+xYoVi5n93HPP0Y033hgz/3rLwAvv448/JjW0aNHCAkWssi1btrSU9ZPw1VdfWeRV5VfTDRo08FOkKO+wLd4030YJaYh07NgxIT716tWzSNavXz9H9SyMXBL87t88rEBkZPEiwzyBSD127Bg99thjNHToUJEcjSO/WrVqpnJp3rw57d+/P5rnVwQ/ioceekhif/nyZQpPwBIe1pMnT0p5SMybN8+cq6lQoQIhH3KD7nfICs/L3HLLLdFmoOTEkRu+En/99ddo/vUewSh31qxZpIbFixdboFm2bJmlHOqhfy2FfSTMnj1bKwdkiRVOnDjho0S5rG+66SZq27ZtLiENsVh9KmIzf/58i2SrVq1KiGsqfsd+929gFAg0rWHIpitMrp0/f97SuSrhypUrVL9+fXrkkUfULM/T7dq1k3hiuPj2228TOlrK0CTwVYMRChSKJttzkjrHsW3bNlq7dq3UTjwTl1SQE4yAAwTw0YSFHA6qcpUUIBAYBfL9999LcOGrHl95EjHNCaxcKliwoCTFypUrzXkZiZghCYyKRFEwvzR69GiRRPFMXFJBTgQKAb9u5uLFi9K8H0zNjRs39qs55usSgcAoENUshAfRJTaeV2/Tpo2FJ0xnFmIGELAUGosSRFF69+5Nffv2FUkEE9cHH3wg0TjBCDhFAL/badOmSdWrVq0qpTmROQgERoHs2bNHQhXLXTEJLRHTnHj88cclCWBfHTNmjETLlATmhkRZIOv69evpwIEDdPToUTGLKlWqJKU5wQi4QUA1nWIBDPZqueHJdf1BIDAKRDdROX36dH9Qc8gVX+tm1Wv/LVq06Fos8y6lS5eWhFqyZEk0PXfu3GgcEdXUBRoHRsApAjt27CB1nq9u3bpO2XE9HxEIjALBEl4VJ2wmxF4KrHxS81Kd1m0Y3LVrV6rFsNUelhGro6URI0ZE62ZnZ0fjiMDUBZMX4hzyFgKDBw+m4cOH2w5NmjRJyQ3+888/Ujv33nsv/fXXXxKNE4kR8Lt/A6NAsE9CNwqBqwP8QLD8FPkNGzY091gkht7bEuoSY3DPVAXy999/QzwpDBw4MJqGixgs6Y0SwhHV5BUm8V8eQOCbb74hfGDZDdirlIrbgrkU7ojEtpo2bSomncavq3p+929gFAieilKlShFWXyGuBqwpx3LZRo0a0bp168z9FMOGDaMXX3xRLepL+oUXXrDwhf8tCzEDCNh4KYqxd+9ewhxIhAblAYUdSeOKFWa4cmAEvEJAnVvDQpnvvvvOK/bMxwMEAqVA4AzxjTfeIOw+T4TNXXfdRT/99BOtWbOG8CLHLvVEddzkY9e2Wn/r1q0qKe1pbA6EA0pREN1cEkYhYhn454LpS6RxnBFwg8DChQtp06ZNEgt1H5WUyYmUIxAoBQL0Vq9eTfhS6dq1K8GnFGiJApTH5s2bfbWxYgOgKsfp06dVUtrTZcqUMd2niIKIS3cj9D59+kSi0avO9BXN5EhGItCqVSvCPgu7oUqVKim9D3UJLz5U4DA1pULk4cb87t/AKRD0NXaW40HHFzG8emIDHCbTkRcrwMSFfQ7vvPNOrCKu6Dr3D1Bcrpj6UPnPP/+UuGJdvroiBgXwZQjX8ohHgmr6itD5mrkIYFIcZl27ITs7O6U3gz0h6lxht27dUipDXm7M7/4NpAIRO3zy5MkENyfYE4LzP3C2xZw5cwgvRrFcJI4zNyJxL6/q3gnwzsSVS+p5FKrrEsgdCViUEInjCtMXTGCIc2AEvEJA3QMCczDOXvGKf97hk3mSBl6BiJDD6y6WtcFJIA4n0n1NYfkqJuPFel7EdSOgTBuBYPSFDZji/cK5H84E0QXkiWWhPGACE2kcZwTcIoAl5AcPHpTY9OrVS0pzIj0IXFcKRIQYK4nKly+v9fYJ99ViWS/iS5cutbCBp2ALMY2EypUrW1r/8MMPaciQIdqgbjZEZdUEBhoHRsAtAlh+L/LAsQwYiYg0jqcegetWgUSgxvAYI5NIGlfdklvQ3QTdSqaXXnrJDUvP63722WeueaomMNcMvWPAnPIwAj179jSX3ou3AJqY5njqEbjuFQggV88B8cO0hH0U6qTzk08+STCZQYZ0B4yGChQo4FoMmMCw38Y1I2bACCgIqAdzlShRglTv1koVTvqMACuQMMCw3Ycv0T+7y3+jFWxGMHmvFm3WrJlKSktaZ76C6Qor0+KF/v37W+TFCjgLkQmMgEsEWrduLW1oNQyDOnTo4JIrV3eDgG0F4qaRTK+rHiSFMzr8kLlRo0YWtt9++62Flg6COvkNsx5OG4RPonjhjz/+sOy38cIUlg4MuM3MRgDzll26dJGEZJOpBEfKE4FRIJhQ27dvH6kbjxIh2r17d8IeELGcbt+DmO80jol0uAUR68NVNQ6+wpG8Il0XR5n27dubx/Tq8p3SYHaCOU2sr/ohEvPUOHYMizSYwti0ICLCca8QaNCgQcwl+MT/Uo5AYBQIXloPP/wwderUibBpr2bNmgnBrFevHqlnD6CSbsIbdC+CenIieGJFyYYNGwj7VJDWBexfwX3BmZ3OMaOujl0aRhGGIR8HnMx+mEGDBlmaYjOWBRIXBK4aQQBOUXVm00g+X1OLQGAUiAgbdqC3bduWMGkN1yZwmli9enWCaQW2frjhwB4G3fwDXpy7d+8W2Xkax9c62lCZFilShI4fP07Lly83lSBMSli6CGWGSX54w8VoRa3nRbpcuXIWNv369bPQYhGwTj8UCknZqXJ6h2XDUKzJBnVCVhLeYQIebXVy6Pob80q6shUqVHDYurNqeLZ0csSj4Rl21po3tWrVqhXTaao3LQSHi9/9G0gFEul+mGawVBZOEzHZNmXKFIINFS8dOFOMlItccdpe2bJlI0nfrnjR6CbUceAURhcww+GlgzmTkiVLmr69fBMmzBjnpoQv0T9s2sILJEpIEMFXIRxSisWefvrpuCMqsaybOMyP+GBINjz//PNumtXWhRlQJwfO9VYrgKYrW7hwYbWor2n8DnRyxKPpzrbxVUiFOXzIjR49WqFyUoeA3/0bGAVy7tw5HX6g2Qrwt4NlgZios1XBZaGsrCyCknDJxnV17LrPly+fxEen3KQCmgT8jYlkwzAIilqkcZwR8AoBmEjVUa9XvJmPfQQCo0AwEY15EHgVhaM/uw8XRh0//PCDuR8D9exD574kRiLw6YP5Dzvy4pAdmJsmTpzovvFrHHTneCRjvrrGhnSbumAyjOR7cY111osT3ufPn3dSLW4dtx8xYO4FD/DRBa94Y8Sp4++Epn6w2e1juAaCnztdm1hBqKP7RdPhCvO5X+3F4quTI1bZePRk+jcwCgSA4BwQmH2effZZuvPOO+nzzz8nTDr36NGDYL6aP38+wV6PMrDRw+SAifdRo0aheloCFF/RokUJ5jZM6MPHD77mFyxYQOPHj6c2bdrQ77//Tg8++CBhh7xuwtqN4BglGIZBhpEb4AE1WZ5QboaRy8MwDNOJZbJ84pXHZkzDkNswDGdpmDXjteUkDws4DMOZPIZxtR68pzpp206dOnXqSP1sGFfbNIzkrvjN2GnPLJPgP/ikM4zc9vPnz5+gRm42nKQaRm5dw7gaL1asWG6hFMSWLFliwVV3BILfoqSjfwOlQMQOwstm6tSp1LFjR6pYsSJ98cUXVLx4cfMQKYxSxo4dSzt27BCrpDWOL2J8xf/777/mi/e9994jHEeJh2LAgAGEw7LSKiA3zggwAoyAgkBgFYhyn5xkBBgBRoAR8BgBViAeA+otO+bGCDACjEDmIsAKJHP7hiVjBBgBRiCjEWAFktHdw8IxAoxAuhDgdhMjwAokMUZcghFgBBgBRkCDACsQDShMYgQYAUaAEUiMACuQxBhxCScIcB1GgBEIPAKsQALfxXyDjAAjwAj4g8D/AAAA///j/lWRAAAABklEQVQDAHjJvjmj1EXsAAAAAElFTkSuQmCC", "sampler": "uCustomTexture" }, "trackMouse": 0, "trackAxes": "xy", "mouseMomentum": 0, "animating": false, "isMask": 0, "compiledFragmentShaders": ["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn max(src, dst);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.7400);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.4000), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(6 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(6 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uCustomTexture, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\nvec3 blended = blend(7, dithered, bg.rgb);\ncolor.rgb = mix(bg.rgb, blended, 1.0000);\nfragColor = color;}"], "compiledVertexShaders": ["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"], "data": { "depth": false, "uniforms": {}, "isBackground": false, "texture": { "src": "", "sampler": "uSprite" } }, "id": "effect6" }], "options": { "name": "UnicornStudio Hero (Remix)", "fps": 60, "dpi": 1.5, "scale": 1, "includeLogo": false, "isProduction": false, "freePlan": false }, "version": "1.5.3", "id": "6GR96VtgB1HqHcc5xIrI" };
    </script>
</head>

<body>
    <div data-us-project="6GR96VtgB1HqHcc5xIrI" style="width: 100vw; height: 100vh;"></div>

    <script>
        !function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).UnicornStudio = {}) }(this, function (e) { "use strict"; var t = Object.defineProperty, s = (e, s, i) => ((e, s, i) => s in e ? t(e, s, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[s] = i)(e, "symbol" != typeof s ? s + "" : s, i); let i = 0; function r() { if (!(i > 100)) { if (100 === i); else { Array.prototype.slice.call(arguments) } i++ } } function a() { Array.prototype.slice.call(arguments) } function n() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, e => { let t = 16 * Math.random() | 0; return ("x" === e ? t : 3 & t | 8).toString(16).toUpperCase() }) } function o(e) { return !(e & e - 1) } let h = class { constructor(e) { if (this.type = "Scene", e && "Renderer" === e.type) { if (!e.gl) return void a(this.type + ": Renderer WebGL context is undefined", e) } else a(this.type + ": Renderer not passed as first argument", e); this.renderer = e, this.gl = e.gl, this.initStacks() } initStacks() { this.stacks = { pingPong: [], renderTargets: [], opaque: [], transparent: [], renderPasses: [], scenePasses: [] } } resetPlaneStacks() { this.stacks.pingPong = [], this.stacks.renderTargets = [], this.stacks.opaque = [], this.stacks.transparent = []; for (let e = 0; e < this.renderer.planes.length; e++)this.addPlane(this.renderer.planes[e]) } resetShaderPassStacks() { this.stacks.scenePasses = [], this.stacks.renderPasses = []; for (let e = 0; e < this.renderer.shaderPasses.length; e++)this.renderer.shaderPasses[e].index = e, this.renderer.shaderPasses[e]._isScenePass ? this.stacks.scenePasses.push(this.renderer.shaderPasses[e]) : this.stacks.renderPasses.push(this.renderer.shaderPasses[e]); 0 === this.stacks.scenePasses.length && (this.renderer.state.scenePassIndex = null) } addToRenderTargetsStack(e) { const t = this.renderer.planes.filter(t => "PingPongPlane" !== t.type && t.target && t.uuid !== e.uuid); let s = -1; if (e.target._depth) { for (let i = t.length - 1; i >= 0; i--)if (t[i].target.uuid === e.target.uuid) { s = i + 1; break } } else s = t.findIndex(t => t.target.uuid === e.target.uuid); s = Math.max(0, s), t.splice(s, 0, e), e.target._depth ? (t.sort((e, t) => e.index - t.index), t.sort((e, t) => t.renderOrder - e.renderOrder)) : (t.sort((e, t) => t.index - e.index), t.sort((e, t) => e.renderOrder - t.renderOrder)), t.sort((e, t) => e.target.index - t.target.index), this.stacks.renderTargets = t } addToRegularPlaneStack(e) { const t = this.renderer.planes.filter(t => "PingPongPlane" !== t.type && !t.target && t._transparent === e._transparent && t.uuid !== e.uuid); let s = -1; for (let i = t.length - 1; i >= 0; i--)if (t[i]._geometry.definition.id === e._geometry.definition.id) { s = i + 1; break } return s = Math.max(0, s), t.splice(s, 0, e), t.sort((e, t) => e.index - t.index), t } addPlane(e) { if ("PingPongPlane" === e.type) this.stacks.pingPong.push(e); else if (e.target) this.addToRenderTargetsStack(e); else if (e._transparent) { const t = this.addToRegularPlaneStack(e); t.sort((e, t) => t.relativeTranslation.z - e.relativeTranslation.z), t.sort((e, t) => t.renderOrder - e.renderOrder), this.stacks.transparent = t } else { const t = this.addToRegularPlaneStack(e); t.sort((e, t) => t.renderOrder - e.renderOrder), this.stacks.opaque = t } } removePlane(e) { "PingPongPlane" === e.type ? this.stacks.pingPong = this.stacks.pingPong.filter(t => t.uuid !== e.uuid) : e.target ? this.stacks.renderTargets = this.stacks.renderTargets.filter(t => t.uuid !== e.uuid) : e._transparent ? this.stacks.transparent = this.stacks.transparent.filter(t => t.uuid !== e.uuid) : this.stacks.opaque = this.stacks.opaque.filter(t => t.uuid !== e.uuid) } setPlaneRenderOrder(e) { if ("ShaderPass" === e.type) this.sortShaderPassStack(e._isScenePass ? this.stacks.scenePasses : this.stacks.renderPasses); else if ("PingPongPlane" === e.type) return; if (e.target) e.target._depth ? (this.stacks.renderTargets.sort((e, t) => e.index - t.index), this.stacks.renderTargets.sort((e, t) => t.renderOrder - e.renderOrder)) : (this.stacks.renderTargets.sort((e, t) => t.index - e.index), this.stacks.renderTargets.sort((e, t) => e.renderOrder - t.renderOrder)), this.stacks.renderTargets.sort((e, t) => e.target.index - t.target.index); else { const t = e._transparent ? this.stacks.transparent : this.stacks.opaque, s = this.stacks.scenePasses.find((e, t) => e._isScenePass && !e._depth && 0 === t); !this.renderer.depth || s ? (t.sort((e, t) => t.index - e.index), e._transparent && t.sort((e, t) => e.relativeTranslation.z - t.relativeTranslation.z), t.sort((e, t) => e.renderOrder - t.renderOrder)) : (t.sort((e, t) => e.index - t.index), e._transparent && t.sort((e, t) => t.relativeTranslation.z - e.relativeTranslation.z), t.sort((e, t) => t.renderOrder - e.renderOrder)) } } addShaderPass(e) { e._isScenePass ? (this.stacks.scenePasses.push(e), this.sortShaderPassStack(this.stacks.scenePasses)) : (this.stacks.renderPasses.push(e), this.sortShaderPassStack(this.stacks.renderPasses)) } removeShaderPass(e) { this.resetShaderPassStacks() } sortShaderPassStack(e) { e.sort((e, t) => e.index - t.index), e.sort((e, t) => e.renderOrder - t.renderOrder) } enableShaderPass() { this.stacks.scenePasses.length && 0 === this.stacks.renderPasses.length && this.renderer.planes.length && (this.renderer.state.scenePassIndex = 0, this.renderer.bindFrameBuffer(this.stacks.scenePasses[0].target)) } drawRenderPasses() { this.stacks.scenePasses.length && this.stacks.renderPasses.length && this.renderer.planes.length && (this.renderer.state.scenePassIndex = 0, this.renderer.bindFrameBuffer(this.stacks.scenePasses[0].target)); for (let e = 0; e < this.stacks.renderPasses.length; e++)this.stacks.renderPasses[e]._startDrawing(), this.renderer.clearDepth() } drawScenePasses() { for (let e = 0; e < this.stacks.scenePasses.length; e++)this.stacks.scenePasses[e]._startDrawing() } drawPingPongStack() { for (let e = 0; e < this.stacks.pingPong.length; e++) { const t = this.stacks.pingPong[e]; t && t._startDrawing() } } drawStack(e) { for (let t = 0; t < this.stacks[e].length; t++) { const s = this.stacks[e][t]; s && s._startDrawing() } } draw() { this.drawPingPongStack(), this.enableShaderPass(), this.drawStack("renderTargets"), this.drawRenderPasses(), this.renderer.setBlending(!1), this.drawStack("opaque"), this.stacks.transparent.length && (this.renderer.setBlending(!0), this.drawStack("transparent")), this.drawScenePasses() } }; class l { constructor() { this.geometries = [], this.clear() } clear() { this.textures = [], this.programs = [] } getGeometryFromID(e) { return this.geometries.find(t => t.id === e) } addGeometry(e, t, s) { this.geometries.push({ id: e, vertices: t, uvs: s }) } isSameShader(e, t) { return 0 === e.localeCompare(t) } getProgramFromShaders(e, t) { return this.programs.find(s => this.isSameShader(s.vsCode, e) && this.isSameShader(s.fsCode, t)) } addProgram(e) { this.programs.push(e) } getTextureFromSource(e) { const t = "string" == typeof e ? e : e.src; return this.textures.find(e => e.source && e.source.src === t) } addTexture(e) { this.getTextureFromSource(e.source) || this.textures.push(e) } removeTexture(e) { this.textures = this.textures.filter(t => t.uuid !== e.uuid) } } class d { constructor() { this.clear() } clear() { this.queue = [] } add(e, t = !1) { const s = { callback: e, keep: t, timeout: null }; return s.timeout = setTimeout(() => { this.queue.push(s) }, 0), s } execute() { this.queue.map(e => { e.callback && e.callback(), clearTimeout(this.queue.timeout) }), this.queue = this.queue.filter(e => e.keep) } } class u { constructor({ alpha: e, antialias: t, premultipliedAlpha: s, depth: i, failIfMajorPerformanceCaveat: a, preserveDrawingBuffer: n, stencil: o, container: h, pixelRatio: l, renderingScale: d, production: u, onError: c, onSuccess: p, onContextLost: m, onContextRestored: g, onDisposed: f, onSceneChange: _ }) { this.type = "Renderer", this.alpha = e, this.antialias = t, this.premultipliedAlpha = s, this.depth = i, this.failIfMajorPerformanceCaveat = a, this.preserveDrawingBuffer = n, this.stencil = o, this.container = h, this.pixelRatio = l, this._renderingScale = d, this.production = u, this.onError = c, this.onSuccess = p, this.onContextLost = m, this.onContextRestored = g, this.onDisposed = f, this.onSceneChange = _, this.initState(), this.canvas = document.createElement("canvas"); const x = { alpha: this.alpha, premultipliedAlpha: this.premultipliedAlpha, antialias: this.antialias, depth: this.depth, failIfMajorPerformanceCaveat: this.failIfMajorPerformanceCaveat, preserveDrawingBuffer: this.preserveDrawingBuffer, stencil: this.stencil }; if (this.gl = this.canvas.getContext("webgl2", x), this._isWebGL2 = !!this.gl, this.gl || (this.gl = this.canvas.getContext("webgl", x) || this.canvas.getContext("experimental-webgl", x)), !this.gl) return this.production || r(this.type + ": WebGL context could not be created"), this.state.isActive = !1, void (this.onError && this.onError()); this.onSuccess && this.onSuccess(), this.initRenderer() } initState() { this.state = { isActive: !0, isContextLost: !0, drawingEnabled: !0, forceRender: !1, currentProgramID: null, currentGeometryID: null, forceBufferUpdate: !1, depthTest: null, blending: null, cullFace: null, frameBufferID: null, scenePassIndex: null, activeTexture: null, unpackAlignment: null, flipY: null, premultiplyAlpha: null } } initCallbackQueueManager() { this.nextRender = new d } initRenderer() { this.planes = [], this.renderTargets = [], this.shaderPasses = [], this.state.isContextLost = !1, this.state.maxTextureSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE), this.initCallbackQueueManager(), this.setBlendFunc(), this.setDepthFunc(), this.setDepthTest(!0), this.cache = new l, this.scene = new h(this), this.getExtensions(), this._contextLostHandler = this.contextLost.bind(this), this.canvas.addEventListener("webglcontextlost", this._contextLostHandler, !1), this._contextRestoredHandler = this.contextRestored.bind(this), this.canvas.addEventListener("webglcontextrestored", this._contextRestoredHandler, !1) } getExtensions() { this.extensions = [], this._isWebGL2 ? (this.extensions.EXT_color_buffer_float = this.gl.getExtension("EXT_color_buffer_float"), this.extensions.OES_texture_float_linear = this.gl.getExtension("OES_texture_float_linear"), this.extensions.EXT_texture_filter_anisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic"), this.extensions.WEBGL_lose_context = this.gl.getExtension("WEBGL_lose_context")) : (this.extensions.OES_vertex_array_object = this.gl.getExtension("OES_vertex_array_object"), this.extensions.OES_texture_float = this.gl.getExtension("OES_texture_float"), this.extensions.OES_texture_float_linear = this.gl.getExtension("OES_texture_float_linear"), this.extensions.OES_texture_half_float = this.gl.getExtension("OES_texture_half_float"), this.extensions.OES_texture_half_float_linear = this.gl.getExtension("OES_texture_half_float_linear"), this.extensions.EXT_texture_filter_anisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic"), this.extensions.OES_element_index_uint = this.gl.getExtension("OES_element_index_uint"), this.extensions.OES_standard_derivatives = this.gl.getExtension("OES_standard_derivatives"), this.extensions.EXT_sRGB = this.gl.getExtension("EXT_sRGB"), this.extensions.WEBGL_depth_texture = this.gl.getExtension("WEBGL_depth_texture"), this.extensions.WEBGL_draw_buffers = this.gl.getExtension("WEBGL_draw_buffers"), this.extensions.WEBGL_lose_context = this.gl.getExtension("WEBGL_lose_context")) } contextLost(e) { this.state.isContextLost = !0, this.state.isActive && (e.preventDefault(), this.nextRender.add(() => this.onContextLost && this.onContextLost())) } restoreContext() { this.state.isActive && (this.initState(), this.gl && this.extensions.WEBGL_lose_context ? this.extensions.WEBGL_lose_context.restoreContext() : (this.gl || this.production ? this.extensions.WEBGL_lose_context || this.production || r(this.type + ": Could not restore the context because the restore context extension is not defined") : r(this.type + ": Could not restore the context because the context is not defined"), this.onError && this.onError())) } isContextexFullyRestored() { let e = !0; for (let t = 0; t < this.renderTargets.length; t++) { this.renderTargets[t].textures[0]._canDraw || (e = !1); break } if (e) for (let t = 0; t < this.planes.length; t++) { if (!this.planes[t]._canDraw) { e = !1; break } for (let s = 0; s < this.planes[t].textures.length; s++)if (!this.planes[t].textures[s]._canDraw) { e = !1; break } } if (e) for (let t = 0; t < this.shaderPasses.length; t++) { if (!this.shaderPasses[t]._canDraw) { e = !1; break } for (let s = 0; s < this.shaderPasses[t].textures.length; s++)if (!this.shaderPasses[t].textures[s]._canDraw) { e = !1; break } } return e } contextRestored() { this.getExtensions(), this.setBlendFunc(), this.setDepthFunc(), this.setDepthTest(!0), this.cache.clear(), this.scene.initStacks(); for (let t = 0; t < this.renderTargets.length; t++)this.renderTargets[t]._restoreContext(); for (let t = 0; t < this.planes.length; t++)this.planes[t]._restoreContext(); for (let t = 0; t < this.shaderPasses.length; t++)this.shaderPasses[t]._restoreContext(); const e = this.nextRender.add(() => { this.isContextexFullyRestored() && (e.keep = !1, this.state.isContextLost = !1, this.onContextRestored && this.onContextRestored(), this.onSceneChange(), this.needRender()) }, !0) } setPixelRatio(e) { this.pixelRatio = e } setSize() { if (!this.gl) return; const e = this.container.getBoundingClientRect(); this._boundingRect = { width: e.width * this.pixelRatio, height: e.height * this.pixelRatio, top: e.top * this.pixelRatio, left: e.left * this.pixelRatio }, this.canvas.style.width = Math.floor(this._boundingRect.width / this.pixelRatio) + "px", this.canvas.style.height = Math.floor(this._boundingRect.height / this.pixelRatio) + "px", this.canvas.width = Math.floor(this._boundingRect.width * this._renderingScale), this.canvas.height = Math.floor(this._boundingRect.height * this._renderingScale), this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight) } resize() { for (let e = 0; e < this.planes.length; e++)this.planes[e]._canDraw && this.planes[e].resize(); for (let e = 0; e < this.shaderPasses.length; e++)this.shaderPasses[e]._canDraw && this.shaderPasses[e].resize(); for (let e = 0; e < this.renderTargets.length; e++)this.renderTargets[e].resize(); this.needRender() } clear() { this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT) } clearDepth() { this.gl.clear(this.gl.DEPTH_BUFFER_BIT) } clearColor() { this.gl.clear(this.gl.COLOR_BUFFER_BIT) } bindFrameBuffer(e, t) { let s = null; e ? (s = e.index, s !== this.state.frameBufferID && (this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, e._frameBuffer), this.gl.viewport(0, 0, e._size.width, e._size.height), e._shouldClear && !t && this.clear())) : null !== this.state.frameBufferID && (this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight)), this.state.frameBufferID = s } setDepthTest(e) { e && !this.state.depthTest ? (this.state.depthTest = e, this.gl.enable(this.gl.DEPTH_TEST)) : !e && this.state.depthTest && (this.state.depthTest = e, this.gl.disable(this.gl.DEPTH_TEST)) } setDepthFunc() { this.gl.depthFunc(this.gl.LEQUAL) } setBlending(e = !1) { e && !this.state.blending ? (this.state.blending = e, this.gl.enable(this.gl.BLEND)) : !e && this.state.blending && (this.state.blending = e, this.gl.disable(this.gl.BLEND)) } setBlendFunc() { this.gl.enable(this.gl.BLEND), this.premultipliedAlpha ? this.gl.blendFuncSeparate(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA) : this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA) } setFaceCulling(e) { if (this.state.cullFace !== e) if (this.state.cullFace = e, "none" === e) this.gl.disable(this.gl.CULL_FACE); else { const t = "front" === e ? this.gl.FRONT : this.gl.BACK; this.gl.enable(this.gl.CULL_FACE), this.gl.cullFace(t) } } useProgram(e) { null !== this.state.currentProgramID && this.state.currentProgramID === e.id || (this.gl.useProgram(e.program), this.state.currentProgramID = e.id) } removePlane(e) { this.gl && (this.planes = this.planes.filter(t => t.uuid !== e.uuid), this.scene.removePlane(e), e = null, this.gl && this.clear(), this.onSceneChange()) } removeRenderTarget(e) { if (!this.gl) return; let t = this.planes.find(t => "PingPongPlane" !== t.type && t.target && t.target.uuid === e.uuid); for (let s = 0; s < this.planes.length; s++)this.planes[s].target && this.planes[s].target.uuid === e.uuid && (this.planes[s].target = null); this.renderTargets = this.renderTargets.filter(t => t.uuid !== e.uuid); for (let s = 0; s < this.renderTargets.length; s++)this.renderTargets[s].index = s; e = null, this.gl && this.clear(), t && this.scene.resetPlaneStacks(), this.onSceneChange() } removeShaderPass(e) { this.gl && (this.shaderPasses = this.shaderPasses.filter(t => t.uuid !== e.uuid), this.scene.removeShaderPass(e), e = null, this.gl && this.clear(), this.onSceneChange()) } enableDrawing() { this.state.drawingEnabled = !0 } disableDrawing() { this.state.drawingEnabled = !1 } needRender() { this.state.forceRender = !0 } render() { this.gl && (this.clear(), this.state.currentGeometryID = null, this.scene.draw()) } deletePrograms() { for (let e = 0; e < this.cache.programs.length; e++) { const t = this.cache.programs[e]; this.gl.deleteProgram(t.program) } } dispose() { if (!this.gl) return; for (this.state.isActive = !1; this.planes.length > 0;)this.removePlane(this.planes[0]); for (; this.shaderPasses.length > 0;)this.removeShaderPass(this.shaderPasses[0]); for (; this.renderTargets.length > 0;)this.removeRenderTarget(this.renderTargets[0]); let e = this.nextRender.add(() => { 0 === this.planes.length && 0 === this.shaderPasses.length && 0 === this.renderTargets.length && (e.keep = !1, this.deletePrograms(), this.clear(), this.canvas.removeEventListener("webgllost", this._contextLostHandler, !1), this.canvas.removeEventListener("webglrestored", this._contextRestoredHandler, !1), this.gl && this.extensions.WEBGL_lose_context && this.extensions.WEBGL_lose_context.loseContext(), this.canvas.width = this.canvas.width, this.gl = null, this.container.removeChild(this.canvas), this.container = null, this.canvas = null, this.onDisposed && this.onDisposed()) }, !0) } } class c { constructor({ xOffset: e = 0, yOffset: t = 0, lastXDelta: s = 0, lastYDelta: i = 0, shouldWatch: r = !0, onScroll: a = () => { } } = {}) { this.xOffset = e, this.yOffset = t, this.lastXDelta = s, this.lastYDelta = i, this.shouldWatch = r, this.onScroll = a, this.handler = this.scroll.bind(this, !0), this.shouldWatch && window.addEventListener("scroll", this.handler, { passive: !0 }) } scroll() { this.updateScrollValues(window.pageXOffset, window.pageYOffset) } updateScrollValues(e, t) { const s = this.xOffset; this.xOffset = e, this.lastXDelta = s - this.xOffset; const i = this.yOffset; this.yOffset = t, this.lastYDelta = i - this.yOffset, this.onScroll && this.onScroll(this.lastXDelta, this.lastYDelta) } dispose() { this.shouldWatch && window.removeEventListener("scroll", this.handler, { passive: !0 }) } } class p { constructor({ container: e, alpha: t = !0, premultipliedAlpha: s = !1, antialias: i = !0, depth: a = !0, failIfMajorPerformanceCaveat: n = !0, preserveDrawingBuffer: o = !1, stencil: h = !1, autoResize: l = !0, autoRender: d = !0, watchScroll: u = !0, pixelRatio: c = window.devicePixelRatio || 1, renderingScale: p = 1, production: m = !1 } = {}) { this.type = "Curtains", this._autoResize = l, this._autoRender = d, this._watchScroll = u, this.pixelRatio = c, p = isNaN(p) ? 1 : parseFloat(p), this._renderingScale = Math.max(.25, Math.min(1, p)), this.premultipliedAlpha = s, this.alpha = t, this.antialias = i, this.depth = a, this.failIfMajorPerformanceCaveat = n, this.preserveDrawingBuffer = o, this.stencil = h, this.production = m, this.errors = !1, e ? this.setContainer(e) : this.production || r(this.type + ": no container provided in the initial parameters. Use setContainer() method to set one later and initialize the WebGL context") } setContainer(e) { if (e) if ("string" == typeof e) if (e = document.getElementById(e)) this.container = e; else { let e = document.createElement("div"); e.setAttribute("id", "curtains-canvas"), document.body.appendChild(e), this.container = e, this.production || r('Curtains: no valid container HTML element or ID provided, created a div with "curtains-canvas" ID instead') } else e instanceof Element && (this.container = e); else { let e = document.createElement("div"); e.setAttribute("id", "curtains-canvas"), document.body.appendChild(e), this.container = e, this.production || r('Curtains: no valid container HTML element or ID provided, created a div with "curtains-canvas" ID instead') } this._initCurtains() } _initCurtains() { this.planes = [], this.renderTargets = [], this.shaderPasses = [], this._initRenderer(), this.gl && (this._initScroll(), this._setSize(), this._addListeners(), this.container.appendChild(this.canvas), this._animationFrameID = null, this._autoRender && this._animate()) } _initRenderer() { this.renderer = new u({ alpha: this.alpha, antialias: this.antialias, premultipliedAlpha: this.premultipliedAlpha, depth: this.depth, failIfMajorPerformanceCaveat: this.failIfMajorPerformanceCaveat, preserveDrawingBuffer: this.preserveDrawingBuffer, stencil: this.stencil, container: this.container, pixelRatio: this.pixelRatio, renderingScale: this._renderingScale, production: this.production, onError: () => this._onRendererError(), onSuccess: () => this._onRendererSuccess(), onContextLost: () => this._onRendererContextLost(), onContextRestored: () => this._onRendererContextRestored(), onDisposed: () => this._onRendererDisposed(), onSceneChange: () => this._keepSync() }), this.gl = this.renderer.gl, this.canvas = this.renderer.canvas } restoreContext() { this.renderer.restoreContext() } _animate() { this.render(), this._animationFrameID = window.requestAnimationFrame(this._animate.bind(this)) } enableDrawing() { this.renderer.enableDrawing() } disableDrawing() { this.renderer.disableDrawing() } needRender() { this.renderer.needRender() } nextRender(e, t = !1) { return this.renderer.nextRender.add(e, t) } clear() { this.renderer && this.renderer.clear() } clearDepth() { this.renderer && this.renderer.clearDepth() } clearColor() { this.renderer && this.renderer.clearColor() } isWebGL2() { return !!this.gl && this.renderer._isWebGL2 } render() { this.renderer.nextRender.execute(), (this.renderer.state.drawingEnabled || this.renderer.state.forceRender) && (this.renderer.state.forceRender && (this.renderer.state.forceRender = !1), this._onRenderCallback && this._onRenderCallback(), this.renderer.render()) } _addListeners() { this._resizeHandler = null, this._autoResize && (this._resizeHandler = this.resize.bind(this, !0), window.addEventListener("resize", this._resizeHandler, !1)) } setPixelRatio(e, t) { this.pixelRatio = parseFloat(Math.max(e, 1)) || 1, this.renderer.setPixelRatio(e), this.resize(t) } _setSize() { this.renderer.setSize(), this._scrollManager.shouldWatch && (this._scrollManager.xOffset = window.pageXOffset, this._scrollManager.yOffset = window.pageYOffset) } getBoundingRect() { return this.renderer._boundingRect } resize(e) { this.gl && (this._setSize(), this.renderer.resize(), this.nextRender(() => { this._onAfterResizeCallback && e && this._onAfterResizeCallback() })) } _initScroll() { this._scrollManager = new c({ xOffset: window.pageXOffset, yOffset: 0, lastXDelta: 0, lastYDelta: 0, shouldWatch: this._watchScroll, onScroll: (e, t) => this._updateScroll(e, t) }) } _updateScroll(e, t) { for (let s = 0; s < this.planes.length; s++)this.planes[s].watchScroll && this.planes[s].updateScrollPosition(e, t); this.renderer.needRender(), this._onScrollCallback && this._onScrollCallback() } updateScrollValues(e, t) { this._scrollManager.updateScrollValues(e, t) } getScrollDeltas() { return { x: this._scrollManager.lastXDelta, y: this._scrollManager.lastYDelta } } getScrollValues() { return { x: this._scrollManager.xOffset, y: this._scrollManager.yOffset } } _keepSync() { this.planes = this.renderer.planes, this.shaderPasses = this.renderer.shaderPasses, this.renderTargets = this.renderer.renderTargets } lerp(e, t, s) { return function (e, t, s) { return (1 - s) * e + s * t }(e, t, s) } onAfterResize(e) { return e && (this._onAfterResizeCallback = e), this } onError(e) { return e && (this._onErrorCallback = e), this } _onRendererError() { setTimeout(() => { this._onErrorCallback && !this.errors && this._onErrorCallback(), this.errors = !0 }, 0) } onSuccess(e) { return e && (this._onSuccessCallback = e), this } _onRendererSuccess() { setTimeout(() => { this._onSuccessCallback && this._onSuccessCallback() }, 0) } onContextLost(e) { return e && (this._onContextLostCallback = e), this } _onRendererContextLost() { this._onContextLostCallback && this._onContextLostCallback() } onContextRestored(e) { return e && (this._onContextRestoredCallback = e), this } _onRendererContextRestored() { this._onContextRestoredCallback && this._onContextRestoredCallback() } onRender(e) { return e && (this._onRenderCallback = e), this } onScroll(e) { return e && (this._onScrollCallback = e), this } dispose() { this.renderer.dispose() } _onRendererDisposed() { this._animationFrameID && window.cancelAnimationFrame(this._animationFrameID), this._resizeHandler && window.removeEventListener("resize", this._resizeHandler, !1), this._scrollManager && this._scrollManager.dispose() } } class m { constructor(e, t, s) { if (this.type = "Uniforms", e && "Renderer" === e.type) { if (!e.gl) return void a(this.type + ": Renderer WebGL context is undefined", e) } else a(this.type + ": Renderer not passed as first argument", e); if (this.renderer = e, this.gl = e.gl, this.program = t, this.uniforms = {}, s) for (const i in s) { const e = s[i]; this.uniforms[i] = { name: e.name, type: e.type, value: e.value.clone && "function" == typeof e.value.clone ? e.value.clone() : e.value, update: null } } } handleUniformSetting(e) { switch (e.type) { case "1i": e.update = this.setUniform1i.bind(this); break; case "1iv": e.update = this.setUniform1iv.bind(this); break; case "1f": e.update = this.setUniform1f.bind(this); break; case "1fv": e.update = this.setUniform1fv.bind(this); break; case "2i": e.update = this.setUniform2i.bind(this); break; case "2iv": e.update = this.setUniform2iv.bind(this); break; case "2f": e.update = this.setUniform2f.bind(this); break; case "2fv": e.update = this.setUniform2fv.bind(this); break; case "3i": e.update = this.setUniform3i.bind(this); break; case "3iv": e.update = this.setUniform3iv.bind(this); break; case "3f": e.update = this.setUniform3f.bind(this); break; case "3fv": e.update = this.setUniform3fv.bind(this); break; case "4i": e.update = this.setUniform4i.bind(this); break; case "4iv": e.update = this.setUniform4iv.bind(this); break; case "4f": e.update = this.setUniform4f.bind(this); break; case "4fv": e.update = this.setUniform4fv.bind(this); break; case "mat2": e.update = this.setUniformMatrix2fv.bind(this); break; case "mat3": e.update = this.setUniformMatrix3fv.bind(this); break; case "mat4": e.update = this.setUniformMatrix4fv.bind(this); break; default: this.renderer.production || r(this.type + ": This uniform type is not handled : ", e.type) } } setInternalFormat(e) { "Vec2" === e.value.type ? (e._internalFormat = "Vec2", e.lastValue = e.value.clone()) : "Vec3" === e.value.type ? (e._internalFormat = "Vec3", e.lastValue = e.value.clone()) : "Mat4" === e.value.type ? (e._internalFormat = "Mat4", e.lastValue = e.value.clone()) : "Quat" === e.value.type ? (e._internalFormat = "Quat", e.lastValue = e.value.clone()) : Array.isArray(e.value) ? (e._internalFormat = "array", e.lastValue = Array.from(e.value)) : e.value.constructor === Float32Array ? (e._internalFormat = "mat", e.lastValue = e.value) : (e._internalFormat = "float", e.lastValue = e.value) } setUniforms() { if (this.uniforms) for (const e in this.uniforms) { let t = this.uniforms[e]; t.location = this.gl.getUniformLocation(this.program, t.name), t._internalFormat || this.setInternalFormat(t), t.type || ("Vec2" === t._internalFormat ? t.type = "2f" : "Vec3" === t._internalFormat ? t.type = "3f" : "Mat4" === t._internalFormat ? t.type = "mat4" : "array" === t._internalFormat ? 4 === t.value.length ? (t.type = "4f", this.renderer.production || r(this.type + ": No uniform type declared for " + t.name + ", applied a 4f (array of 4 floats) uniform type")) : 3 === t.value.length ? (t.type = "3f", this.renderer.production || r(this.type + ": No uniform type declared for " + t.name + ", applied a 3f (array of 3 floats) uniform type")) : 2 === t.value.length && (t.type = "2f", this.renderer.production || r(this.type + ": No uniform type declared for " + t.name + ", applied a 2f (array of 2 floats) uniform type")) : "mat" === t._internalFormat ? 16 === t.value.length ? (t.type = "mat4", this.renderer.production || r(this.type + ": No uniform type declared for " + t.name + ", applied a mat4 (4x4 matrix array) uniform type")) : 9 === t.value.length ? (t.type = "mat3", this.renderer.production || r(this.type + ": No uniform type declared for " + t.name + ", applied a mat3 (3x3 matrix array) uniform type")) : 4 === t.value.length && (t.type = "mat2", this.renderer.production || r(this.type + ": No uniform type declared for " + t.name + ", applied a mat2 (2x2 matrix array) uniform type")) : (t.type = "1f", this.renderer.production || r(this.type + ": No uniform type declared for " + t.name + ", applied a 1f (float) uniform type"))), this.handleUniformSetting(t), t.update && t.update(t) } } updateUniforms() { if (this.uniforms) for (const e in this.uniforms) { const t = this.uniforms[e]; let s = !1; "Vec2" === t._internalFormat || "Vec3" === t._internalFormat || "Quat" === t._internalFormat ? t.value.equals(t.lastValue) || (s = !0, t.lastValue.copy(t.value)) : t.value.length ? JSON.stringify(t.value) !== JSON.stringify(t.lastValue) && (s = !0, t.lastValue = Array.from(t.value)) : t.value !== t.lastValue && (s = !0, t.lastValue = t.value), s && t.update && t.update(t) } } setUniform1i(e) { this.gl.uniform1i(e.location, e.value) } setUniform1iv(e) { this.gl.uniform1iv(e.location, e.value) } setUniform1f(e) { this.gl.uniform1f(e.location, e.value) } setUniform1fv(e) { this.gl.uniform1fv(e.location, e.value) } setUniform2i(e) { "Vec2" === e._internalFormat ? this.gl.uniform2i(e.location, e.value.x, e.value.y) : this.gl.uniform2i(e.location, e.value[0], e.value[1]) } setUniform2iv(e) { "Vec2" === e._internalFormat ? this.gl.uniform2iv(e.location, [e.value.x, e.value.y]) : this.gl.uniform2iv(e.location, e.value) } setUniform2f(e) { "Vec2" === e._internalFormat ? this.gl.uniform2f(e.location, e.value.x, e.value.y) : this.gl.uniform2f(e.location, e.value[0], e.value[1]) } setUniform2fv(e) { "Vec2" === e._internalFormat ? this.gl.uniform2fv(e.location, [e.value.x, e.value.y]) : this.gl.uniform2fv(e.location, e.value) } setUniform3i(e) { "Vec3" === e._internalFormat ? this.gl.uniform3i(e.location, e.value.x, e.value.y, e.value.z) : this.gl.uniform3i(e.location, e.value[0], e.value[1], e.value[2]) } setUniform3iv(e) { "Vec3" === e._internalFormat ? this.gl.uniform3iv(e.location, [e.value.x, e.value.y, e.value.z]) : this.gl.uniform3iv(e.location, e.value) } setUniform3f(e) { "Vec3" === e._internalFormat ? this.gl.uniform3f(e.location, e.value.x, e.value.y, e.value.z) : this.gl.uniform3f(e.location, e.value[0], e.value[1], e.value[2]) } setUniform3fv(e) { "Vec3" === e._internalFormat ? this.gl.uniform3fv(e.location, [e.value.x, e.value.y, e.value.z]) : this.gl.uniform3fv(e.location, e.value) } setUniform4i(e) { "Quat" === e._internalFormat ? this.gl.uniform4i(e.location, e.value.elements[0], e.value.elements[1], e.value.elements[2], e.value[3]) : this.gl.uniform4i(e.location, e.value[0], e.value[1], e.value[2], e.value[3]) } setUniform4iv(e) { "Quat" === e._internalFormat ? this.gl.uniform4iv(e.location, [e.value.elements[0], e.value.elements[1], e.value.elements[2], e.value[3]]) : this.gl.uniform4iv(e.location, e.value) } setUniform4f(e) { "Quat" === e._internalFormat ? this.gl.uniform4f(e.location, e.value.elements[0], e.value.elements[1], e.value.elements[2], e.value[3]) : this.gl.uniform4f(e.location, e.value[0], e.value[1], e.value[2], e.value[3]) } setUniform4fv(e) { "Quat" === e._internalFormat ? this.gl.uniform4fv(e.location, [e.value.elements[0], e.value.elements[1], e.value.elements[2], e.value[3]]) : this.gl.uniform4fv(e.location, e.value) } setUniformMatrix2fv(e) { this.gl.uniformMatrix2fv(e.location, !1, e.value) } setUniformMatrix3fv(e) { this.gl.uniformMatrix3fv(e.location, !1, e.value) } setUniformMatrix4fv(e) { "Mat4" === e._internalFormat ? this.gl.uniformMatrix4fv(e.location, !1, e.value.elements) : this.gl.uniformMatrix4fv(e.location, !1, e.value) } } const g = "\nprecision mediump float;\n".replace(/\n/g, ""), f = "\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\n".replace(/\n/g, ""), _ = "\nvarying vec3 vVertexPosition;\nvarying vec2 vTextureCoord;\n".replace(/\n/g, ""), x = (g + f + _ + "\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\n\nvoid main() {\n    vTextureCoord = aTextureCoord;\n    vVertexPosition = aVertexPosition;\n    \n    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n}\n").replace(/\n/g, ""), v = (g + _ + "\nvoid main() {\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n").replace(/\n/g, ""), y = (g + f + _ + "\nvoid main() {\n    vTextureCoord = aTextureCoord;\n    vVertexPosition = aVertexPosition;\n    \n    gl_Position = vec4(aVertexPosition, 1.0);\n}\n").replace(/\n/g, ""), b = (g + _ + "\nuniform sampler2D uRenderTexture;\n\nvoid main() {\n    gl_FragColor = texture2D(uRenderTexture, vTextureCoord);\n}\n").replace(/\n/g, ""); let P = 0; class w { constructor(e, { parent: t, vertexShader: s, fragmentShader: i } = {}) { if (this.type = "Program", e && "Renderer" === e.type) { if (!e.gl) return void a(this.type + ": Renderer WebGL context is undefined", e) } else a(this.type + ": Renderer not passed as first argument", e); this.renderer = e, this.gl = this.renderer.gl, this.parent = t, this.defaultVsCode = "Plane" === this.parent.type ? x : y, this.defaultFsCode = "Plane" === this.parent.type ? v : b, s ? this.vsCode = s : (this.renderer.production || "Plane" !== this.parent.type || r(this.parent.type + ": No vertex shader provided, will use a default one"), this.vsCode = this.defaultVsCode), i ? this.fsCode = i : (this.renderer.production || r(this.parent.type + ": No fragment shader provided, will use a default one"), this.fsCode = this.defaultFsCode), this.compiled = !0, this.setupProgram() } createShader(e, t) { const s = this.gl.createShader(t); if (this.gl.shaderSource(s, e), this.gl.compileShader(s), !this.renderer.production && !this.gl.getShaderParameter(s, this.gl.COMPILE_STATUS)) { const e = t === this.gl.VERTEX_SHADER ? "vertex shader" : "fragment shader"; let i = this.gl.getShaderSource(s).split("\n"); for (let t = 0; t < i.length; t++)i[t] = t + 1 + ": " + i[t]; return i = i.join("\n"), r(this.type + ": Errors occurred while compiling the", e, ":\n", this.gl.getShaderInfoLog(s)), a(i), r(this.type + ": Will use a default", e), this.createShader(t === this.gl.VERTEX_SHADER ? this.defaultVsCode : this.defaultFsCode, t) } return s } useNewShaders() { this.vertexShader = this.createShader(this.vsCode, this.gl.VERTEX_SHADER), this.fragmentShader = this.createShader(this.fsCode, this.gl.FRAGMENT_SHADER), this.vertexShader && this.fragmentShader || this.renderer.production || r(this.type + ": Unable to find or compile the vertex or fragment shader") } setupProgram() { let e = this.renderer.cache.getProgramFromShaders(this.vsCode, this.fsCode); e ? (this.vertexShader = e.vertexShader, this.fragmentShader = e.fragmentShader, this.activeUniforms = e.activeUniforms, this.activeAttributes = e.activeAttributes, this.createProgram()) : (this.useNewShaders(), this.compiled && (this.createProgram(), this.renderer.cache.addProgram(this))) } createProgram() { if (P++, this.id = P, this.program = this.gl.createProgram(), this.gl.attachShader(this.program, this.vertexShader), this.gl.attachShader(this.program, this.fragmentShader), this.gl.linkProgram(this.program), !this.renderer.production && !this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) return r(this.type + ": Unable to initialize the shader program: " + this.gl.getProgramInfoLog(this.program)), r(this.type + ": Will use default vertex and fragment shaders"), this.vertexShader = this.createShader(this.defaultVsCode, this.gl.VERTEX_SHADER), this.fragmentShader = this.createShader(this.defaultFsCode, this.gl.FRAGMENT_SHADER), void this.createProgram(); if (this.gl.deleteShader(this.vertexShader), this.gl.deleteShader(this.fragmentShader), !this.activeUniforms || !this.activeAttributes) { this.activeUniforms = { textures: [], textureMatrices: [] }; const e = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS); for (let s = 0; s < e; s++) { const e = this.gl.getActiveUniform(this.program, s); e.type === this.gl.SAMPLER_2D && this.activeUniforms.textures.push(e.name), e.type === this.gl.FLOAT_MAT4 && "uMVMatrix" !== e.name && "uPMatrix" !== e.name && this.activeUniforms.textureMatrices.push(e.name) } this.activeAttributes = []; const t = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES); for (let s = 0; s < t; s++) { const e = this.gl.getActiveAttrib(this.program, s); this.activeAttributes.push(e.name) } } } createUniforms(e) { this.uniformsManager = new m(this.renderer, this.program, e), this.setUniforms() } setUniforms() { this.renderer.useProgram(this), this.uniformsManager.setUniforms() } updateUniforms() { this.renderer.useProgram(this), this.uniformsManager.updateUniforms() } } class T { constructor(e, { program: t = null, width: s = 1, height: i = 1 } = {}) { if (this.type = "Geometry", e && "Renderer" === e.type) { if (!e.gl) return void a(this.type + ": Renderer WebGL context is undefined", e) } else a(this.type + ": Renderer not passed as first argument", e); this.renderer = e, this.gl = this.renderer.gl, this.definition = { id: s * i + s, width: s, height: i }, this.setDefaultAttributes(), this.setVerticesUVs() } restoreContext(e) { this.program = null, this.setDefaultAttributes(), this.setVerticesUVs(), this.setProgram(e) } setDefaultAttributes() { this.attributes = { vertexPosition: { name: "aVertexPosition", size: 3, isActive: !1 }, textureCoord: { name: "aTextureCoord", size: 3, isActive: !1 } } } setVerticesUVs() { const e = this.renderer.cache.getGeometryFromID(this.definition.id); e ? (this.attributes.vertexPosition.array = e.vertices, this.attributes.textureCoord.array = e.uvs) : (this.computeVerticesUVs(), this.renderer.cache.addGeometry(this.definition.id, this.attributes.vertexPosition.array, this.attributes.textureCoord.array)) } setProgram(e) { this.program = e, this.initAttributes(), this.renderer._isWebGL2 ? (this._vao = this.gl.createVertexArray(), this.gl.bindVertexArray(this._vao)) : this.renderer.extensions.OES_vertex_array_object && (this._vao = this.renderer.extensions.OES_vertex_array_object.createVertexArrayOES(), this.renderer.extensions.OES_vertex_array_object.bindVertexArrayOES(this._vao)), this.initializeBuffers() } initAttributes() { for (const e in this.attributes) { if (this.attributes[e].isActive = this.program.activeAttributes.includes(this.attributes[e].name), !this.attributes[e].isActive) return; this.attributes[e].location = this.gl.getAttribLocation(this.program.program, this.attributes[e].name), this.attributes[e].buffer = this.gl.createBuffer(), this.attributes[e].numberOfItems = this.definition.width * this.definition.height * this.attributes[e].size * 2 } } computeVerticesUVs() { this.attributes.vertexPosition.array = [], this.attributes.textureCoord.array = []; const e = this.attributes.vertexPosition.array, t = this.attributes.textureCoord.array; for (let s = 0; s < this.definition.height; s++) { const i = s / this.definition.height; for (let s = 0; s < this.definition.width; s++) { const r = s / this.definition.width; t.push(r), t.push(i), t.push(0), e.push(2 * (r - .5)), e.push(2 * (i - .5)), e.push(0), t.push(r + 1 / this.definition.width), t.push(i), t.push(0), e.push(2 * (r + 1 / this.definition.width - .5)), e.push(2 * (i - .5)), e.push(0), t.push(r), t.push(i + 1 / this.definition.height), t.push(0), e.push(2 * (r - .5)), e.push(2 * (i + 1 / this.definition.height - .5)), e.push(0), t.push(r), t.push(i + 1 / this.definition.height), t.push(0), e.push(2 * (r - .5)), e.push(2 * (i + 1 / this.definition.height - .5)), e.push(0), t.push(r + 1 / this.definition.width), t.push(i), t.push(0), e.push(2 * (r + 1 / this.definition.width - .5)), e.push(2 * (i - .5)), e.push(0), t.push(r + 1 / this.definition.width), t.push(i + 1 / this.definition.height), t.push(0), e.push(2 * (r + 1 / this.definition.width - .5)), e.push(2 * (i + 1 / this.definition.height - .5)), e.push(0) } } } initializeBuffers() { if (this.attributes) { for (const e in this.attributes) { if (!this.attributes[e].isActive) return; this.gl.enableVertexAttribArray(this.attributes[e].location), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.attributes[e].buffer), this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.attributes[e].array), this.gl.STATIC_DRAW), this.gl.vertexAttribPointer(this.attributes[e].location, this.attributes[e].size, this.gl.FLOAT, !1, 0, 0) } this.renderer.state.currentGeometryID = this.definition.id } } bindBuffers() { if (this._vao) this.renderer._isWebGL2 ? this.gl.bindVertexArray(this._vao) : this.renderer.extensions.OES_vertex_array_object.bindVertexArrayOES(this._vao); else for (const e in this.attributes) { if (!this.attributes[e].isActive) return; this.gl.enableVertexAttribArray(this.attributes[e].location), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.attributes[e].buffer), this.gl.vertexAttribPointer(this.attributes[e].location, this.attributes[e].size, this.gl.FLOAT, !1, 0, 0) } this.renderer.state.currentGeometryID = this.definition.id } draw() { this.gl.drawArrays(this.gl.TRIANGLES, 0, this.attributes.vertexPosition.numberOfItems) } dispose() { this._vao && (this.renderer._isWebGL2 ? this.gl.deleteVertexArray(this._vao) : this.renderer.extensions.OES_vertex_array_object.deleteVertexArrayOES(this._vao)); for (const e in this.attributes) { if (!this.attributes[e].isActive) return; this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.attributes[e].buffer), this.gl.bufferData(this.gl.ARRAY_BUFFER, 1, this.gl.STATIC_DRAW), this.gl.deleteBuffer(this.attributes[e].buffer) } this.attributes = null, this.renderer.state.currentGeometryID = null } } class R { constructor(e = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])) { this.type = "Mat4", this.elements = e } setFromArray(e) { for (let t = 0; t < this.elements.length; t++)this.elements[t] = e[t]; return this } copy(e) { const t = e.elements; return this.elements[0] = t[0], this.elements[1] = t[1], this.elements[2] = t[2], this.elements[3] = t[3], this.elements[4] = t[4], this.elements[5] = t[5], this.elements[6] = t[6], this.elements[7] = t[7], this.elements[8] = t[8], this.elements[9] = t[9], this.elements[10] = t[10], this.elements[11] = t[11], this.elements[12] = t[12], this.elements[13] = t[13], this.elements[14] = t[14], this.elements[15] = t[15], this } clone() { return (new R).copy(this) } multiply(e) { const t = this.elements, s = e.elements; let i = new R; return i.elements[0] = s[0] * t[0] + s[1] * t[4] + s[2] * t[8] + s[3] * t[12], i.elements[1] = s[0] * t[1] + s[1] * t[5] + s[2] * t[9] + s[3] * t[13], i.elements[2] = s[0] * t[2] + s[1] * t[6] + s[2] * t[10] + s[3] * t[14], i.elements[3] = s[0] * t[3] + s[1] * t[7] + s[2] * t[11] + s[3] * t[15], i.elements[4] = s[4] * t[0] + s[5] * t[4] + s[6] * t[8] + s[7] * t[12], i.elements[5] = s[4] * t[1] + s[5] * t[5] + s[6] * t[9] + s[7] * t[13], i.elements[6] = s[4] * t[2] + s[5] * t[6] + s[6] * t[10] + s[7] * t[14], i.elements[7] = s[4] * t[3] + s[5] * t[7] + s[6] * t[11] + s[7] * t[15], i.elements[8] = s[8] * t[0] + s[9] * t[4] + s[10] * t[8] + s[11] * t[12], i.elements[9] = s[8] * t[1] + s[9] * t[5] + s[10] * t[9] + s[11] * t[13], i.elements[10] = s[8] * t[2] + s[9] * t[6] + s[10] * t[10] + s[11] * t[14], i.elements[11] = s[8] * t[3] + s[9] * t[7] + s[10] * t[11] + s[11] * t[15], i.elements[12] = s[12] * t[0] + s[13] * t[4] + s[14] * t[8] + s[15] * t[12], i.elements[13] = s[12] * t[1] + s[13] * t[5] + s[14] * t[9] + s[15] * t[13], i.elements[14] = s[12] * t[2] + s[13] * t[6] + s[14] * t[10] + s[15] * t[14], i.elements[15] = s[12] * t[3] + s[13] * t[7] + s[14] * t[11] + s[15] * t[15], i } getInverse() { const e = this.elements, t = new R, s = t.elements; let i = e[0], r = e[1], a = e[2], n = e[3], o = e[4], h = e[5], l = e[6], d = e[7], u = e[8], c = e[9], p = e[10], m = e[11], g = e[12], f = e[13], _ = e[14], x = e[15], v = i * h - r * o, y = i * l - a * o, b = i * d - n * o, P = r * l - a * h, w = r * d - n * h, T = a * d - n * l, S = u * f - c * g, M = u * _ - p * g, E = u * x - m * g, C = c * _ - p * f, k = c * x - m * f, A = p * x - m * _, F = v * A - y * k + b * C + P * E - w * M + T * S; return F ? (F = 1 / F, s[0] = (h * A - l * k + d * C) * F, s[1] = (a * k - r * A - n * C) * F, s[2] = (f * T - _ * w + x * P) * F, s[3] = (p * w - c * T - m * P) * F, s[4] = (l * E - o * A - d * M) * F, s[5] = (i * A - a * E + n * M) * F, s[6] = (_ * b - g * T - x * y) * F, s[7] = (u * T - p * b + m * y) * F, s[8] = (o * k - h * E + d * S) * F, s[9] = (r * E - i * k - n * S) * F, s[10] = (g * w - f * b + x * v) * F, s[11] = (c * b - u * w - m * v) * F, s[12] = (h * M - o * C - l * S) * F, s[13] = (i * C - r * M + a * S) * F, s[14] = (f * y - g * P - _ * v) * F, s[15] = (u * P - c * y + p * v) * F, t) : null } scale(e) { let t = this.elements; return t[0] *= e.x, t[1] *= e.x, t[2] *= e.x, t[3] *= e.x, t[4] *= e.y, t[5] *= e.y, t[6] *= e.y, t[7] *= e.y, t[8] *= e.z, t[9] *= e.z, t[10] *= e.z, t[11] *= e.z, this } compose(e, t, s) { let i = this.elements; const r = t.elements[0], a = t.elements[1], n = t.elements[2], o = t.elements[3], h = r + r, l = a + a, d = n + n, u = r * h, c = r * l, p = r * d, m = a * l, g = a * d, f = n * d, _ = o * h, x = o * l, v = o * d, y = s.x, b = s.y, P = s.z; return i[0] = (1 - (m + f)) * y, i[1] = (c + v) * y, i[2] = (p - x) * y, i[3] = 0, i[4] = (c - v) * b, i[5] = (1 - (u + f)) * b, i[6] = (g + _) * b, i[7] = 0, i[8] = (p + x) * P, i[9] = (g - _) * P, i[10] = (1 - (u + m)) * P, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this } composeFromOrigin(e, t, s, i) { let r = this.elements; const a = t.elements[0], n = t.elements[1], o = t.elements[2], h = t.elements[3], l = a + a, d = n + n, u = o + o, c = a * l, p = a * d, m = a * u, g = n * d, f = n * u, _ = o * u, x = h * l, v = h * d, y = h * u, b = s.x, P = s.y, w = s.z, T = i.x, R = i.y, S = i.z, M = (1 - (g + _)) * b, E = (p + y) * b, C = (m - v) * b, k = (p - y) * P, A = (1 - (c + _)) * P, F = (f + x) * P, D = (m + v) * w, I = (f - x) * w, O = (1 - (c + g)) * w; return r[0] = M, r[1] = E, r[2] = C, r[3] = 0, r[4] = k, r[5] = A, r[6] = F, r[7] = 0, r[8] = D, r[9] = I, r[10] = O, r[11] = 0, r[12] = e.x + T - (M * T + k * R + D * S), r[13] = e.y + R - (E * T + A * R + I * S), r[14] = e.z + S - (C * T + F * R + O * S), r[15] = 1, this } } class S { constructor(e = 0, t = e) { this.type = "Vec2", this._x = e, this._y = t } get x() { return this._x } get y() { return this._y } set x(e) { const t = e !== this._x; this._x = e, t && this._onChangeCallback && this._onChangeCallback() } set y(e) { const t = e !== this._y; this._y = e, t && this._onChangeCallback && this._onChangeCallback() } onChange(e) { return e && (this._onChangeCallback = e), this } set(e, t) { return this._x = e, this._y = t, this } add(e) { return this._x += e.x, this._y += e.y, this } addScalar(e) { return this._x += e, this._y += e, this } sub(e) { return this._x -= e.x, this._y -= e.y, this } subScalar(e) { return this._x -= e, this._y -= e, this } multiply(e) { return this._x *= e.x, this._y *= e.y, this } multiplyScalar(e) { return this._x *= e, this._y *= e, this } copy(e) { return this._x = e.x, this._y = e.y, this } clone() { return new S(this._x, this._y) } sanitizeNaNValuesWith(e) { return this._x = isNaN(this._x) ? e.x : parseFloat(this._x), this._y = isNaN(this._y) ? e.y : parseFloat(this._y), this } max(e) { return this._x = Math.max(this._x, e.x), this._y = Math.max(this._y, e.y), this } min(e) { return this._x = Math.min(this._x, e.x), this._y = Math.min(this._y, e.y), this } equals(e) { return this._x === e.x && this._y === e.y } normalize() { let e = this._x * this._x + this._y * this._y; return e > 0 && (e = 1 / Math.sqrt(e)), this._x *= e, this._y *= e, this } dot(e) { return this._x * e.x + this._y * e.y } } class M { constructor(e = 0, t = e, s = e) { this.type = "Vec3", this._x = e, this._y = t, this._z = s } get x() { return this._x } get y() { return this._y } get z() { return this._z } set x(e) { const t = e !== this._x; this._x = e, t && this._onChangeCallback && this._onChangeCallback() } set y(e) { const t = e !== this._y; this._y = e, t && this._onChangeCallback && this._onChangeCallback() } set z(e) { const t = e !== this._z; this._z = e, t && this._onChangeCallback && this._onChangeCallback() } onChange(e) { return e && (this._onChangeCallback = e), this } set(e, t, s) { return this._x = e, this._y = t, this._z = s, this } add(e) { return this._x += e.x, this._y += e.y, this._z += e.z, this } addScalar(e) { return this._x += e, this._y += e, this._z += e, this } sub(e) { return this._x -= e.x, this._y -= e.y, this._z -= e.z, this } subScalar(e) { return this._x -= e, this._y -= e, this._z -= e, this } multiply(e) { return this._x *= e.x, this._y *= e.y, this._z *= e.z, this } multiplyScalar(e) { return this._x *= e, this._y *= e, this._z *= e, this } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this } clone() { return new M(this._x, this._y, this._z) } sanitizeNaNValuesWith(e) { return this._x = isNaN(this._x) ? e.x : parseFloat(this._x), this._y = isNaN(this._y) ? e.y : parseFloat(this._y), this._z = isNaN(this._z) ? e.z : parseFloat(this._z), this } max(e) { return this._x = Math.max(this._x, e.x), this._y = Math.max(this._y, e.y), this._z = Math.max(this._z, e.z), this } min(e) { return this._x = Math.min(this._x, e.x), this._y = Math.min(this._y, e.y), this._z = Math.min(this._z, e.z), this } equals(e) { return this._x === e.x && this._y === e.y && this._z === e.z } normalize() { let e = this._x * this._x + this._y * this._y + this._z * this._z; return e > 0 && (e = 1 / Math.sqrt(e)), this._x *= e, this._y *= e, this._z *= e, this } dot(e) { return this._x * e.x + this._y * e.y + this._z * e.z } applyMat4(e) { const t = this._x, s = this._y, i = this._z, r = e.elements; let a = r[3] * t + r[7] * s + r[11] * i + r[15]; return a = a || 1, this._x = (r[0] * t + r[4] * s + r[8] * i + r[12]) / a, this._y = (r[1] * t + r[5] * s + r[9] * i + r[13]) / a, this._z = (r[2] * t + r[6] * s + r[10] * i + r[14]) / a, this } applyQuat(e) { const t = this._x, s = this._y, i = this._z, r = e.elements[0], a = e.elements[1], n = e.elements[2], o = e.elements[3], h = o * t + a * i - n * s, l = o * s + n * t - r * i, d = o * i + r * s - a * t, u = -r * t - a * s - n * i; return this._x = h * o + u * -r + l * -n - d * -a, this._y = l * o + u * -a + d * -r - h * -n, this._z = d * o + u * -n + h * -a - l * -r, this } project(e) { return this.applyMat4(e.viewMatrix).applyMat4(e.projectionMatrix), this } unproject(e) { return this.applyMat4(e.projectionMatrix.getInverse()).applyMat4(e.worldMatrix), this } } const E = new S, C = new M, k = new R; class A { constructor(e, { isFBOTexture: t = !1, fromTexture: s = !1, loader: i, sampler: r, floatingPoint: o = "none", premultiplyAlpha: h = !1, anisotropy: l = 1, generateMipmap: d = null, wrapS: u, wrapT: c, minFilter: p, magFilter: m } = {}) { if (this.type = "Texture", (e = e && e.renderer || e) && "Renderer" === e.type) { if (!e.gl) return void (e.production || a(this.type + ": Unable to create a " + this.type + " because the Renderer WebGL context is not defined")) } else a(this.type + ": Renderer not passed as first argument", e); if (this.renderer = e, this.gl = this.renderer.gl, this.uuid = n(), this._globalParameters = { unpackAlignment: 4, flipY: !t, premultiplyAlpha: !1, shouldPremultiplyAlpha: h, floatingPoint: o, type: this.gl.UNSIGNED_BYTE, internalFormat: this.gl.RGBA, format: this.gl.RGBA }, this.parameters = { anisotropy: l, generateMipmap: d, wrapS: u || this.gl.CLAMP_TO_EDGE, wrapT: c || this.gl.CLAMP_TO_EDGE, minFilter: p || this.gl.LINEAR, magFilter: m || this.gl.LINEAR, _shouldUpdate: !0 }, this._initState(), this.sourceType = t ? "fbo" : "empty", this._useCache = !0, this._samplerName = r, this._sampler = { isActive: !1, isTextureBound: !1, texture: this.gl.createTexture() }, this._textureMatrix = { matrix: new R, isActive: !1 }, this._size = { width: 1, height: 1 }, this.scale = new S(1), this.scale.onChange(() => this.resize()), this.offset = new S, this.offset.onChange(() => this.resize()), this._loader = i, this._sourceLoaded = !1, this._uploaded = !1, this._willUpdate = !1, this.shouldUpdate = !1, this._forceUpdate = !1, this.userData = {}, this._canDraw = !1, s) return this._copyOnInit = !0, void (this._copiedFrom = s); this._copyOnInit = !1, this._initTexture() } _initState() { this._state = { anisotropy: 1, generateMipmap: !1, wrapS: null, wrapT: null, minFilter: null, magFilter: this.gl.LINEAR } } _initTexture() { this.gl.bindTexture(this.gl.TEXTURE_2D, this._sampler.texture), "empty" === this.sourceType && (this._globalParameters.flipY = !1, this._updateGlobalTexParameters(), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255])), this._canDraw = !0) } _restoreFromTexture() { this._copyOnInit || this._initTexture(), this._parent && (this._setTextureUniforms(), this._setSize()), this.copy(this._copiedFrom), this._canDraw = !0 } _restoreContext() { if (this._canDraw = !1, this._sampler.texture = this.gl.createTexture(), this._sampler.isActive = !1, this._sampler.isTextureBound = !1, this._textureMatrix.isActive = !1, this._initState(), this._state.generateMipmap = !1, this.parameters._shouldUpdate = !0, this._copiedFrom) { const e = this.renderer.nextRender.add(() => { this._copiedFrom._canDraw && (this._restoreFromTexture(), e.keep = !1) }, !0) } else this._initTexture(), this._parent && this._setParent(), this.source && (this.setSource(this.source), "image" === this.sourceType ? this.renderer.cache.addTexture(this) : this.needUpdate()), this._canDraw = !0 } addParent(e) { !e || "Plane" !== e.type && "PingPongPlane" !== e.type && "ShaderPass" !== e.type && "RenderTarget" !== e.type ? this.renderer.production || r(this.type + ": cannot add texture as a child of ", e, " because it is not a valid parent") : (this._parent = e, this.index = this._parent.textures.length, this._parent.textures.push(this), this._setParent()) } _setParent() { if (this._sampler.name = this._samplerName || "uSampler" + this.index, this._textureMatrix.name = this._samplerName ? this._samplerName + "Matrix" : "uTextureMatrix" + this.index, this._parent._program) { if (!this._parent._program.compiled) return void (this.renderer.production || r(this.type + ": Unable to create the texture because the program is not valid")); if (this._setTextureUniforms(), this._copyOnInit) { const e = this.renderer.nextRender.add(() => { this._copiedFrom._canDraw && this._copiedFrom._uploaded && (this.copy(this._copiedFrom), e.keep = !1) }, !0); return } this.source ? this._parent.loader && this._parent.loader._addSourceToParent(this.source, this.sourceType) : this._size = { width: this._parent._boundingRect.document.width, height: this._parent._boundingRect.document.height }, this._setSize() } else "RenderTarget" === this._parent.type && (this._size = { width: this._parent._size && this._parent._size.width || this.renderer._boundingRect.width, height: this._parent._size && this._parent._size.height || this.renderer._boundingRect.height }, this._upload(), this._updateTexParameters(), this._canDraw = !0) } hasParent() { return !!this._parent } _setTextureUniforms() { const e = this._parent._program.activeUniforms; for (let t = 0; t < e.textures.length; t++)if (e.textures[t] === this._sampler.name) { this._sampler.isActive = !0, this.renderer.useProgram(this._parent._program), this._sampler.location = this.gl.getUniformLocation(this._parent._program.program, this._sampler.name); e.textureMatrices.find(e => e === this._textureMatrix.name) && (this._textureMatrix.isActive = !0, this._textureMatrix.location = this.gl.getUniformLocation(this._parent._program.program, this._textureMatrix.name)), this.gl.uniform1i(this._sampler.location, this.index) } } copy(e) { e && "Texture" === e.type ? (this._globalParameters = Object.assign({}, e._globalParameters), this._state = Object.assign({}, e._state), this.parameters.generateMipmap = e.parameters.generateMipmap, this._state.generateMipmap = null, this._size = e._size, !this._sourceLoaded && e._sourceLoaded && this._onSourceLoadedCallback && this._onSourceLoadedCallback(), this._sourceLoaded = e._sourceLoaded, !this._uploaded && e._uploaded && this._onSourceUploadedCallback && this._onSourceUploadedCallback(), this._uploaded = e._uploaded, this.sourceType = e.sourceType, this.source = e.source, this._videoFrameCallbackID = e._videoFrameCallbackID, this._sampler.texture = e._sampler.texture, this._copiedFrom = e, !this._parent || !this._parent._program || this._canDraw && this._textureMatrix.matrix || (this._setSize(), this._canDraw = !0), this._updateTexParameters(), this.renderer.needRender()) : this.renderer.production || r(this.type + ": Unable to set the texture from texture:", e) } setSource(e) { this._sourceLoaded || this.renderer.nextRender.add(() => this._onSourceLoadedCallback && this._onSourceLoadedCallback()); const t = "IMG" === e.tagName.toUpperCase() ? "image" : e.tagName.toLowerCase(); if ("video" !== t && "canvas" !== t || (this._useCache = !1), this._useCache) { const t = this.renderer.cache.getTextureFromSource(e); if (t && t.uuid !== this.uuid) return this._uploaded || (this.renderer.nextRender.add(() => this._onSourceUploadedCallback && this._onSourceUploadedCallback()), this._uploaded = !0), this.copy(t), void this.resize() } if ("empty" === this.sourceType || this.sourceType !== t) if ("video" === t) this._willUpdate = !1, this.shouldUpdate = !0; else if ("canvas" === t) this._willUpdate = !0, this.shouldUpdate = !0; else { if ("image" !== t) return void (this.renderer.production || r(this.type + ": this HTML tag could not be converted into a texture:", e.tagName)); this._willUpdate = !1, this.shouldUpdate = !1 } this.source = e, this.sourceType = t, this._size = { width: this.source.naturalWidth || this.source.width || this.source.videoWidth, height: this.source.naturalHeight || this.source.height || this.source.videoHeight }, this._sourceLoaded = !0, this.gl.bindTexture(this.gl.TEXTURE_2D, this._sampler.texture), this.resize(), this._globalParameters.flipY = !0, this._globalParameters.premultiplyAlpha = this._globalParameters.shouldPremultiplyAlpha, "image" === this.sourceType && (this.parameters.generateMipmap = this.parameters.generateMipmap || null === this.parameters.generateMipmap, this.parameters._shouldUpdate = this.parameters.generateMipmap, this._state.generateMipmap = !1, this._upload()), this.renderer.needRender() } _updateGlobalTexParameters() { this.renderer.state.unpackAlignment !== this._globalParameters.unpackAlignment && (this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this._globalParameters.unpackAlignment), this.renderer.state.unpackAlignment = this._globalParameters.unpackAlignment), this.renderer.state.flipY !== this._globalParameters.flipY && (this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this._globalParameters.flipY), this.renderer.state.flipY = this._globalParameters.flipY), this.renderer.state.premultiplyAlpha !== this._globalParameters.premultiplyAlpha && (this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._globalParameters.premultiplyAlpha), this.renderer.state.premultiplyAlpha = this._globalParameters.premultiplyAlpha), "half-float" === this._globalParameters.floatingPoint ? this.renderer._isWebGL2 && this.renderer.extensions.EXT_color_buffer_float ? (this._globalParameters.internalFormat = this.gl.RGBA16F, this._globalParameters.type = this.gl.HALF_FLOAT) : this.renderer.extensions.OES_texture_half_float ? this._globalParameters.type = this.renderer.extensions.OES_texture_half_float.HALF_FLOAT_OES : this.renderer.production || r(this.type + ": could not use half-float textures because the extension is not available") : "float" === this._globalParameters.floatingPoint && (this.renderer._isWebGL2 && this.renderer.extensions.EXT_color_buffer_float ? (this._globalParameters.internalFormat = this.gl.RGBA16F, this._globalParameters.type = this.gl.FLOAT) : this.renderer.extensions.OES_texture_float ? this._globalParameters.type = this.renderer.extensions.OES_texture_half_float.FLOAT : this.renderer.production || r(this.type + ": could not use float textures because the extension is not available")) } _updateTexParameters() { this.index && this.renderer.state.activeTexture !== this.index && this._bindTexture(), this.parameters.wrapS !== this._state.wrapS && (this.renderer._isWebGL2 || o(this._size.width) && o(this._size.height) || (this.parameters.wrapS = this.gl.CLAMP_TO_EDGE), this.parameters.wrapS !== this.gl.REPEAT && this.parameters.wrapS !== this.gl.CLAMP_TO_EDGE && this.parameters.wrapS !== this.gl.MIRRORED_REPEAT && (this.renderer.production || r(this.type + ": Wrong wrapS value", this.parameters.wrapS, "for this texture:", this, "\ngl.CLAMP_TO_EDGE wrapping will be used instead"), this.parameters.wrapS = this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.parameters.wrapS), this._state.wrapS = this.parameters.wrapS), this.parameters.wrapT !== this._state.wrapT && (this.renderer._isWebGL2 || o(this._size.width) && o(this._size.height) || (this.parameters.wrapT = this.gl.CLAMP_TO_EDGE), this.parameters.wrapT !== this.gl.REPEAT && this.parameters.wrapT !== this.gl.CLAMP_TO_EDGE && this.parameters.wrapT !== this.gl.MIRRORED_REPEAT && (this.renderer.production || r(this.type + ": Wrong wrapT value", this.parameters.wrapT, "for this texture:", this, "\ngl.CLAMP_TO_EDGE wrapping will be used instead"), this.parameters.wrapT = this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.parameters.wrapT), this._state.wrapT = this.parameters.wrapT), this.parameters.generateMipmap && !this._state.generateMipmap && this.source && (this.renderer._isWebGL2 || o(this._size.width) && o(this._size.height) ? this.gl.generateMipmap(this.gl.TEXTURE_2D) : this.parameters.generateMipmap = !1, this._state.generateMipmap = this.parameters.generateMipmap), this.parameters.minFilter !== this._state.minFilter && (this.renderer._isWebGL2 || o(this._size.width) && o(this._size.height) || (this.parameters.minFilter = this.gl.LINEAR), this.parameters.generateMipmap || null === this.parameters.generateMipmap || (this.parameters.minFilter = this.gl.LINEAR), this.parameters.minFilter !== this.gl.LINEAR && this.parameters.minFilter !== this.gl.NEAREST && this.parameters.minFilter !== this.gl.NEAREST_MIPMAP_NEAREST && this.parameters.minFilter !== this.gl.LINEAR_MIPMAP_NEAREST && this.parameters.minFilter !== this.gl.NEAREST_MIPMAP_LINEAR && this.parameters.minFilter !== this.gl.LINEAR_MIPMAP_LINEAR && (this.renderer.production || r(this.type + ": Wrong minFilter value", this.parameters.minFilter, "for this texture:", this, "\ngl.LINEAR filtering will be used instead"), this.parameters.minFilter = this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.parameters.minFilter), this._state.minFilter = this.parameters.minFilter), this.parameters.magFilter !== this._state.magFilter && (this.renderer._isWebGL2 || o(this._size.width) && o(this._size.height) || (this.parameters.magFilter = this.gl.LINEAR), this.parameters.magFilter !== this.gl.LINEAR && this.parameters.magFilter !== this.gl.NEAREST && (this.renderer.production || r(this.type + ": Wrong magFilter value", this.parameters.magFilter, "for this texture:", this, "\ngl.LINEAR filtering will be used instead"), this.parameters.magFilter = this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.parameters.magFilter), this._state.magFilter = this.parameters.magFilter); const e = this.renderer.extensions.EXT_texture_filter_anisotropic; if (e && this.parameters.anisotropy !== this._state.anisotropy) { const t = this.gl.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT); this.parameters.anisotropy = Math.max(1, Math.min(this.parameters.anisotropy, t)), this.gl.texParameterf(this.gl.TEXTURE_2D, e.TEXTURE_MAX_ANISOTROPY_EXT, this.parameters.anisotropy), this._state.anisotropy = this.parameters.anisotropy } } setWrapS(e) { this.parameters.wrapS !== e && (this.parameters.wrapS = e, this.parameters._shouldUpdate = !0) } setWrapT(e) { this.parameters.wrapT !== e && (this.parameters.wrapT = e, this.parameters._shouldUpdate = !0) } setMinFilter(e) { this.parameters.minFilter !== e && (this.parameters.minFilter = e, this.parameters._shouldUpdate = !0) } setMagFilter(e) { this.parameters.magFilter !== e && (this.parameters.magFilter = e, this.parameters._shouldUpdate = !0) } setAnisotropy(e) { e = isNaN(e) ? this.parameters.anisotropy : e, this.parameters.anisotropy !== e && (this.parameters.anisotropy = e, this.parameters._shouldUpdate = !0) } needUpdate() { this._forceUpdate = !0 } _videoFrameCallback() { if (this._willUpdate = !0, this.source) this.source.requestVideoFrameCallback(() => this._videoFrameCallback()); else { const e = this.renderer.nextRender.add(() => { this.source && (e.keep = !1, this.source.requestVideoFrameCallback(() => this._videoFrameCallback())) }, !0) } } _upload() { this._updateGlobalTexParameters(), this.source ? this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this._globalParameters.internalFormat, this._globalParameters.format, this._globalParameters.type, this.source) : "fbo" === this.sourceType && this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this._globalParameters.internalFormat, this._size.width, this._size.height, 0, this._globalParameters.format, this._globalParameters.type, this.source || null), this._uploaded || (this.renderer.nextRender.add(() => this._onSourceUploadedCallback && this._onSourceUploadedCallback()), this._uploaded = !0) } _getSizes() { if ("fbo" === this.sourceType) return { parentWidth: this._parent._boundingRect.document.width, parentHeight: this._parent._boundingRect.document.height, sourceWidth: this._parent._boundingRect.document.width, sourceHeight: this._parent._boundingRect.document.height, xOffset: 0, yOffset: 0 }; const e = this._parent.scale ? E.set(this._parent.scale.x, this._parent.scale.y) : E.set(1, 1), t = this._parent._boundingRect.document.width * e.x, s = this._parent._boundingRect.document.height * e.y, i = this._size.width, r = this._size.height, a = i / r, n = t / s; let o = 0, h = 0; return n > a ? h = Math.min(0, s - t * (1 / a)) : n < a && (o = Math.min(0, t - s * a)), { parentWidth: t, parentHeight: s, sourceWidth: i, sourceHeight: r, xOffset: o, yOffset: h } } setScale(e) { e.type && "Vec2" === e.type ? (e.sanitizeNaNValuesWith(this.scale).max(E.set(.001, .001)), e.equals(this.scale) || (this.scale.copy(e), this.resize())) : this.renderer.production || r(this.type + ": Cannot set scale because the parameter passed is not of Vec2 type:", e) } setOffset(e) { e.type && "Vec2" === e.type ? (e.sanitizeNaNValuesWith(this.offset), e.equals(this.offset) || (this.offset.copy(e), this.resize())) : this.renderer.production || r(this.type + ": Cannot set offset because the parameter passed is not of Vec2 type:", scale) } _setSize() { if (this._parent && this._parent._program) { const e = this._getSizes(); this._updateTextureMatrix(e) } } resize() { "fbo" === this.sourceType ? (this._size = { width: this._parent._size && this._parent._size.width || this._parent._boundingRect.document.width, height: this._parent._size && this._parent._size.height || this._parent._boundingRect.document.height }, this._copiedFrom || (this.gl.bindTexture(this.gl.TEXTURE_2D, this._sampler.texture), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this._globalParameters.internalFormat, this._size.width, this._size.height, 0, this._globalParameters.format, this._globalParameters.type, null))) : this.source && (this._size = { width: this.source.naturalWidth || this.source.width || this.source.videoWidth, height: this.source.naturalHeight || this.source.height || this.source.videoHeight }), this._setSize() } _updateTextureMatrix(e) { const t = C.set(e.parentWidth / (e.parentWidth - e.xOffset), e.parentHeight / (e.parentHeight - e.yOffset), 1); t.x /= this.scale.x, t.y /= this.scale.y, this._textureMatrix.matrix = k.setFromArray([t.x, 0, 0, 0, 0, t.y, 0, 0, 0, 0, 1, 0, (1 - t.x) / 2 + this.offset.x, (1 - t.y) / 2 + this.offset.y, 0, 1]), this._updateMatrixUniform() } _updateMatrixUniform() { this._textureMatrix.isActive && (this.renderer.useProgram(this._parent._program), this.gl.uniformMatrix4fv(this._textureMatrix.location, !1, this._textureMatrix.matrix.elements)) } _onSourceLoaded(e) { this.setSource(e), "image" === this.sourceType && this.renderer.cache.addTexture(this) } _bindTexture() { this._canDraw && (this.renderer.state.activeTexture !== this.index && (this.gl.activeTexture(this.gl.TEXTURE0 + this.index), this.renderer.state.activeTexture = this.index), this.gl.bindTexture(this.gl.TEXTURE_2D, this._sampler.texture), this._sampler.isTextureBound || (this._sampler.isTextureBound = !!this.gl.getParameter(this.gl.TEXTURE_BINDING_2D), this._sampler.isTextureBound && this.renderer.needRender())) } _draw() { this._sampler.isActive && (this._bindTexture(), "video" === this.sourceType && this.source && !this._videoFrameCallbackID && this.source.readyState >= this.source.HAVE_CURRENT_DATA && !this.source.paused && (this._willUpdate = !0), (this._forceUpdate || this._willUpdate && this.shouldUpdate) && (this._state.generateMipmap = !1, this._upload()), "video" === this.sourceType && (this._willUpdate = !1), this._forceUpdate = !1), this.parameters._shouldUpdate && (this._updateTexParameters(), this.parameters._shouldUpdate = !1) } onSourceLoaded(e) { return e && (this._onSourceLoadedCallback = e), this } onSourceUploaded(e) { return e && (this._onSourceUploadedCallback = e), this } _dispose(e = !1) { var t; "video" === this.sourceType || "image" === this.sourceType && !this.renderer.state.isActive ? (this._loader && this._loader._removeSource(this), this.source = null) : "canvas" === this.sourceType && this.source && (this.source.width = null == (t = this.source) ? void 0 : t.width, this.source = null), this._parent = null; this.gl && !this._copiedFrom && (e || "image" !== this.sourceType || !this.renderer.state.isActive) && (this._canDraw = !1, this.renderer.cache.removeTexture(this), this.gl.activeTexture(this.gl.TEXTURE0 + this.index), this.gl.bindTexture(this.gl.TEXTURE_2D, null), this.gl.deleteTexture(this._sampler.texture)) } } class F { constructor(e, t = "anonymous") { if (this.type = "TextureLoader", (e = e && e.renderer || e) && "Renderer" === e.type) { if (!e.gl) return void a(this.type + ": Renderer WebGL context is undefined", e) } else a(this.type + ": Renderer not passed as first argument", e); this.renderer = e, this.gl = this.renderer.gl, this.crossOrigin = t, this.elements = [] } _addElement(e, t, s, i) { const r = { source: e, texture: t, load: this._sourceLoaded.bind(this, e, t, s), error: this._sourceLoadError.bind(this, e, i) }; return this.elements.push(r), r } _sourceLoadError(e, t, s) { t && t(e, s) } _sourceLoaded(e, t, s) { t._sourceLoaded || (t._onSourceLoaded(e), this._parent && (this._increment && this._increment(), this.renderer.nextRender.add(() => this._parent._onLoadingCallback && this._parent._onLoadingCallback(t))), s && s(t)) } _getSourceType(e) { let t; return "string" == typeof e ? null !== e.match(/\.(jpeg|jpg|jfif|pjpeg|pjp|gif|bmp|png|webp|svg|avif|apng)$/) ? t = "image" : null !== e.match(/\.(webm|mp4|mpg|mpeg|avi|ogg|ogm|ogv|mov|av1)$/) && (t = "video") : "IMG" === e.tagName.toUpperCase() ? t = "image" : "VIDEO" === e.tagName.toUpperCase() ? t = "video" : "CANVAS" === e.tagName.toUpperCase() && (t = "canvas"), t } _createImage(e) { if ("string" != typeof e && e.hasAttribute("crossOrigin")) return e; { const t = new Image; return t.crossOrigin = this.crossOrigin, "string" == typeof e ? t.src = e : (t.src = e.src, e.hasAttribute("data-sampler") && t.setAttribute("data-sampler", e.getAttribute("data-sampler"))), t } } _createVideo(e) { if ("string" == typeof e || null === e.getAttribute("crossOrigin")) { const t = document.createElement("video"); return t.crossOrigin = this.crossOrigin, "string" == typeof e ? t.src = e : (t.src = e.src, e.hasAttribute("data-sampler") && t.setAttribute("data-sampler", e.getAttribute("data-sampler"))), t } return e } loadSource(e, t, s, i) { switch (this._getSourceType(e)) { case "image": this.loadImage(e, t, s, i); break; case "video": this.loadVideo(e, t, s, i); break; case "canvas": this.loadCanvas(e, t, s); break; default: this._sourceLoadError(e, i, "this source could not be converted into a texture: " + e) } } loadSources(e, t, s, i) { for (let r = 0; r < e.length; r++)this.loadSource(e[r], t, s, i) } loadImage(e, t = {}, s, i) { const r = this.renderer.cache.getTextureFromSource(e); let a = Object.assign({}, t); if (this._parent && (a = Object.assign(a, this._parent._texturesOptions)), a.loader = this, r) { a.sampler = "string" != typeof e && e.hasAttribute("data-sampler") ? e.getAttribute("data-sampler") : a.sampler, a.fromTexture = r; const t = new A(this.renderer, a); return this._sourceLoaded(r.source, t, s), void (this._parent && this._addToParent(t, r.source, "image")) } const n = this._createImage(e); a.sampler = n.hasAttribute("data-sampler") ? n.getAttribute("data-sampler") : a.sampler; const o = new A(this.renderer, a), h = this._addElement(n, o, s, i); n.complete ? this._sourceLoaded(n, o, s) : n.decode ? n.decode().then(this._sourceLoaded.bind(this, n, o, s)).catch(() => { n.addEventListener("load", h.load, !1), n.addEventListener("error", h.error, !1) }) : (n.addEventListener("load", h.load, !1), n.addEventListener("error", h.error, !1)), this._parent && this._addToParent(o, n, "image") } loadImages(e, t, s, i) { for (let r = 0; r < e.length; r++)this.loadImage(e[r], t, s, i) } loadVideo(e, t = {}, s, i) { const r = this._createVideo(e); r.preload = !0, r.muted = !0, r.loop = !0, r.setAttribute("playsinline", ""), r.crossOrigin = this.crossOrigin; let a = Object.assign({}, t); this._parent && (a = Object.assign(t, this._parent._texturesOptions)), a.loader = this, a.sampler = r.hasAttribute("data-sampler") ? r.getAttribute("data-sampler") : a.sampler; const n = new A(this.renderer, a), o = this._addElement(r, n, s, i); r.addEventListener("canplaythrough", o.load, !1), r.addEventListener("error", o.error, !1), r.readyState >= r.HAVE_FUTURE_DATA && s && this._sourceLoaded(r, n, s), r.load(), this._addToParent && this._addToParent(n, r, "video"), "requestVideoFrameCallback" in HTMLVideoElement.prototype && (o.videoFrameCallback = n._videoFrameCallback.bind(n), n._videoFrameCallbackID = r.requestVideoFrameCallback(o.videoFrameCallback)) } loadVideos(e, t, s, i) { for (let r = 0; r < e.length; r++)this.loadVideo(e[r], t, s, i) } loadCanvas(e, t = {}, s) { let i = Object.assign({}, t); this._parent && (i = Object.assign(t, this._parent._texturesOptions)), i.loader = this, i.sampler = e.hasAttribute("data-sampler") ? e.getAttribute("data-sampler") : i.sampler; const r = new A(this.renderer, i); this._addElement(e, r, s, null), this._sourceLoaded(e, r, s), this._parent && this._addToParent(r, e, "canvas") } loadCanvases(e, t, s) { for (let i = 0; i < e.length; i++)this.loadCanvas(e[i], t, s) } _removeSource(e) { const t = this.elements.find(t => t.texture.uuid === e.uuid); t && ("image" === e.sourceType ? t.source.removeEventListener("load", t.load, !1) : "video" === e.sourceType && (t.videoFrameCallback && e._videoFrameCallbackID && t.source.cancelVideoFrameCallback(e._videoFrameCallbackID), t.source.removeEventListener("canplaythrough", t.load, !1), t.source.pause(), t.source.removeAttribute("src"), t.source.load()), t.source.removeEventListener("error", t.error, !1)) } } class D extends F { constructor(e, t, { sourcesLoaded: s = 0, sourcesToLoad: i = 0, complete: a = !1, onComplete: n = () => { } } = {}) { super(e, t.crossOrigin), this.type = "PlaneTextureLoader", this._parent = t, "Plane" !== this._parent.type && "PingPongPlane" !== this._parent.type && "ShaderPass" !== this._parent.type && (r(this.type + ": Wrong parent type assigned to this loader"), this._parent = null), this.sourcesLoaded = s, this.sourcesToLoad = i, this.complete = a, this.onComplete = n } _setLoaderSize(e) { this.sourcesToLoad = e, 0 === this.sourcesToLoad && (this.complete = !0, this.renderer.nextRender.add(() => this.onComplete && this.onComplete())) } _increment() { this.sourcesLoaded++, this.sourcesLoaded >= this.sourcesToLoad && !this.complete && (this.complete = !0, this.renderer.nextRender.add(() => this.onComplete && this.onComplete())) } _addSourceToParent(e, t) { if ("image" === t) { const t = this._parent.images; !t.find(t => t.src === e.src) && t.push(e) } else if ("video" === t) { const t = this._parent.videos; !t.find(t => t.src === e.src) && t.push(e) } else if ("canvas" === t) { const t = this._parent.canvases; !t.find(t => t.isSameNode(e)) && t.push(e) } } _addToParent(e, t, s) { this._addSourceToParent(t, s), this._parent && e.addParent(this._parent) } } class I { constructor(e, t = "Mesh", { vertexShaderID: s, fragmentShaderID: i, vertexShader: r, fragmentShader: n, uniforms: o = {}, widthSegments: h = 1, heightSegments: l = 1, renderOrder: d = 0, depthTest: u = !0, cullFace: c = "back", texturesOptions: p = {}, crossOrigin: m = "anonymous" } = {}) { if (this.type = t, (e = e && e.renderer || e) && "Renderer" === e.type || (a(this.type + ": Curtains not passed as first argument or Curtains Renderer is missing", e), setTimeout(() => { this._onErrorCallback && this._onErrorCallback() }, 0)), this.renderer = e, this.gl = this.renderer.gl, !this.gl) return this.renderer.production || a(this.type + ": Unable to create a " + this.type + " because the Renderer WebGL context is not defined"), void setTimeout(() => { this._onErrorCallback && this._onErrorCallback() }, 0); this._canDraw = !1, this.renderOrder = d, this._depthTest = u, this.cullFace = c, "back" !== this.cullFace && "front" !== this.cullFace && "none" !== this.cullFace && (this.cullFace = "back"), this.textures = [], this._texturesOptions = Object.assign({ premultiplyAlpha: !1, anisotropy: 1, floatingPoint: "none", wrapS: this.gl.CLAMP_TO_EDGE, wrapT: this.gl.CLAMP_TO_EDGE, minFilter: this.gl.LINEAR, magFilter: this.gl.LINEAR }, p), this.crossOrigin = m, !r && s && document.getElementById(s) && (r = document.getElementById(s).innerHTML), !n && i && document.getElementById(i) && (n = document.getElementById(i).innerHTML), this._initMesh(), h = parseInt(h), l = parseInt(l), this._geometry = new T(this.renderer, { width: h, height: l }), this._program = new w(this.renderer, { parent: this, vertexShader: r, fragmentShader: n }), this._program.compiled ? (this._program.createUniforms(o), this.uniforms = this._program.uniformsManager.uniforms, this._geometry.setProgram(this._program), this.renderer.onSceneChange()) : this.renderer.nextRender.add(() => this._onErrorCallback && this._onErrorCallback()) } _initMesh() { this.uuid = n(), this.loader = new D(this.renderer, this, { sourcesLoaded: 0, initSourcesToLoad: 0, complete: !1, onComplete: () => { this._onReadyCallback && this._onReadyCallback(), this.renderer.needRender() } }), this.images = [], this.videos = [], this.canvases = [], this.userData = {}, this._canDraw = !0 } _restoreContext() { this._canDraw = !1, this._matrices && (this._matrices = null), this._program = new w(this.renderer, { parent: this, vertexShader: this._program.vsCode, fragmentShader: this._program.fsCode }), this._program.compiled && (this._geometry.restoreContext(this._program), this._program.createUniforms(this.uniforms), this.uniforms = this._program.uniformsManager.uniforms, this._programRestored()) } setRenderTarget(e) { e && "RenderTarget" === e.type ? ("Plane" === this.type && this.renderer.scene.removePlane(this), this.target = e, "Plane" === this.type && this.renderer.scene.addPlane(this)) : this.renderer.production || r(this.type + ": Could not set the render target because the argument passed is not a RenderTarget class object", e) } setRenderOrder(e = 0) { (e = isNaN(e) ? this.renderOrder : parseInt(e)) !== this.renderOrder && (this.renderOrder = e, this.renderer.scene.setPlaneRenderOrder(this)) } createTexture(e = {}) { const t = new A(this.renderer, Object.assign(e, this._texturesOptions)); return t.addParent(this), t } addTexture(e) { e && "Texture" === e.type ? e.addParent(this) : this.renderer.production || r(this.type + ": cannot add ", e, " to this " + this.type + " because it is not a valid texture") } loadSources(e, t = {}, s, i) { for (let r = 0; r < e.length; r++)this.loadSource(e[r], t, s, i) } loadSource(e, t = {}, s, i) { this.loader.loadSource(e, Object.assign(t, this._texturesOptions), e => { s && s(e) }, (e, t) => { this.renderer.production || r(this.type + ": this HTML tag could not be converted into a texture:", e.tagName), i && i(e, t) }) } loadImage(e, t = {}, s, i) { this.loader.loadImage(e, Object.assign(t, this._texturesOptions), e => { s && s(e) }, (e, t) => { this.renderer.production || r(this.type + ": There has been an error:\n", t, "\nwhile loading this image:\n", e), i && i(e, t) }) } loadVideo(e, t = {}, s, i) { this.loader.loadVideo(e, Object.assign(t, this._texturesOptions), e => { s && s(e) }, (e, t) => { this.renderer.production || r(this.type + ": There has been an error:\n", t, "\nwhile loading this video:\n", e), i && i(e, t) }) } loadCanvas(e, t = {}, s) { this.loader.loadCanvas(e, Object.assign(t, this._texturesOptions), e => { s && s(e) }) } loadImages(e, t = {}, s, i) { for (let r = 0; r < e.length; r++)this.loadImage(e[r], t, s, i) } loadVideos(e, t = {}, s, i) { for (let r = 0; r < e.length; r++)this.loadVideo(e[r], t, s, i) } loadCanvases(e, t = {}, s) { for (let i = 0; i < e.length; i++)this.loadCanvas(e[i], t, s) } playVideos() { for (let e = 0; e < this.textures.length; e++) { const t = this.textures[e]; if ("video" === t.sourceType) { const e = t.source.play(); void 0 !== e && e.catch(e => { this.renderer.production || r(this.type + ": Could not play the video : ", e) }) } } } _draw() { this.renderer.setDepthTest(this._depthTest), this.renderer.setFaceCulling(this.cullFace), this._program.updateUniforms(), this._geometry.bindBuffers(), this.renderer.state.forceBufferUpdate = !1; for (let e = 0; e < this.textures.length; e++)if (this.textures[e]._draw(), this.textures[e]._sampler.isActive && !this.textures[e]._sampler.isTextureBound) return; this._geometry.draw(), this.renderer.state.activeTexture = null, this._onAfterRenderCallback && this._onAfterRenderCallback() } onError(e) { return e && (this._onErrorCallback = e), this } onLoading(e) { return e && (this._onLoadingCallback = e), this } onReady(e) { return e && (this._onReadyCallback = e), this } onRender(e) { return e && (this._onRenderCallback = e), this } onAfterRender(e) { return e && (this._onAfterRenderCallback = e), this } remove() { this._canDraw = !1, this.target && this.renderer.bindFrameBuffer(null), this._dispose(), "Plane" === this.type ? this.renderer.removePlane(this) : "ShaderPass" === this.type && (this.target && (this.target._shaderPass = null, this.target.remove(), this.target = null), this.renderer.removeShaderPass(this)) } _dispose() { if (this.gl) { this._geometry && this._geometry.dispose(), this.target && "ShaderPass" === this.type && (this.renderer.removeRenderTarget(this.target), this.textures.shift()); for (let e = 0; e < this.textures.length; e++)this.textures[e]._dispose(); this.textures = [] } } } const O = new S, z = new S; class L extends I { constructor(e, t, s = "DOMMesh", { widthSegments: i, heightSegments: a, renderOrder: n, depthTest: o, cullFace: h, uniforms: l, vertexShaderID: d, fragmentShaderID: u, vertexShader: c, fragmentShader: p, texturesOptions: m, crossOrigin: g } = {}) { super(e, s, { widthSegments: i, heightSegments: a, renderOrder: n, depthTest: o, cullFace: h, uniforms: l, vertexShaderID: d = d || t && t.getAttribute("data-vs-id"), fragmentShaderID: u = u || t && t.getAttribute("data-fs-id"), vertexShader: c, fragmentShader: p, texturesOptions: m, crossOrigin: g }), this.gl && (this.htmlElement = t, this.htmlElement && 0 !== this.htmlElement.length || this.renderer.production || r(this.type + ": The HTML element you specified does not currently exists in the DOM"), this._setDocumentSizes()) } _setDocumentSizes() { let e = this.htmlElement.getBoundingClientRect(); this._boundingRect || (this._boundingRect = {}), this._boundingRect.document = { width: e.width * this.renderer.pixelRatio, height: e.height * this.renderer.pixelRatio, top: e.top * this.renderer.pixelRatio, left: e.left * this.renderer.pixelRatio } } getBoundingRect() { return { width: this._boundingRect.document.width, height: this._boundingRect.document.height, top: this._boundingRect.document.top, left: this._boundingRect.document.left, right: this._boundingRect.document.left + this._boundingRect.document.width, bottom: this._boundingRect.document.top + this._boundingRect.document.height } } resize() { this._setDocumentSizes(), "Plane" === this.type && (this.setPerspective(this.camera.fov, this.camera.near, this.camera.far), this._setWorldSizes(), this._applyWorldPositions()); for (let e = 0; e < this.textures.length; e++)this.textures[e].resize(); this.renderer.nextRender.add(() => this._onAfterResizeCallback && this._onAfterResizeCallback()) } mouseToPlaneCoords(e) { const t = this.scale ? this.scale : z.set(1, 1), s = O.set((this._boundingRect.document.width - this._boundingRect.document.width * t.x) / 2, (this._boundingRect.document.height - this._boundingRect.document.height * t.y) / 2), i = this._boundingRect.document.width * t.x / this.renderer.pixelRatio, r = this._boundingRect.document.height * t.y / this.renderer.pixelRatio, a = (this._boundingRect.document.top + s.y) / this.renderer.pixelRatio, n = (this._boundingRect.document.left + s.x) / this.renderer.pixelRatio; return O.set((e.x - n) / i * 2 - 1, 1 - (e.y - a) / r * 2) } onAfterResize(e) { return e && (this._onAfterResizeCallback = e), this } } class U { constructor({ fov: e = 50, near: t = .1, far: s = 150, width: i, height: r, pixelRatio: a = 1 } = {}) { this.position = new M, this.projectionMatrix = new R, this.worldMatrix = new R, this.viewMatrix = new R, this._shouldUpdate = !1, this.setSize(), this.setPerspective(e, t, s, i, r, a) } setFov(e) { e = isNaN(e) ? this.fov : parseFloat(e), (e = Math.max(1, Math.min(e, 179))) !== this.fov && (this.fov = e, this.setPosition(), this._shouldUpdate = !0), this.setCSSPerspective() } setNear(e) { e = isNaN(e) ? this.near : parseFloat(e), (e = Math.max(e, .01)) !== this.near && (this.near = e, this._shouldUpdate = !0) } setFar(e) { e = isNaN(e) ? this.far : parseFloat(e), (e = Math.max(e, 50)) !== this.far && (this.far = e, this._shouldUpdate = !0) } setPixelRatio(e) { e !== this.pixelRatio && (this._shouldUpdate = !0), this.pixelRatio = e } setSize(e, t) { e === this.width && t === this.height || (this._shouldUpdate = !0), this.width = e, this.height = t } setPerspective(e, t, s, i, r, a) { this.setPixelRatio(a), this.setSize(i, r), this.setFov(e), this.setNear(t), this.setFar(s), this._shouldUpdate && this.updateProjectionMatrix() } setPosition() { this.position.set(0, 0, 1), this.worldMatrix.setFromArray([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, this.position.x, this.position.y, this.position.z, 1]), this.viewMatrix = this.viewMatrix.copy(this.worldMatrix).getInverse() } setCSSPerspective() { this.CSSPerspective = Math.pow(Math.pow(this.width / (2 * this.pixelRatio), 2) + Math.pow(this.height / (2 * this.pixelRatio), 2), .5) / Math.tan(.5 * this.fov * Math.PI / 180) } getScreenRatiosFromFov(e = 0) { const t = this.position.z; e < t ? e -= t : e += t; const s = this.fov * Math.PI / 180, i = 2 * Math.tan(s / 2) * Math.abs(e); return { width: i * this.width / this.height, height: i } } updateProjectionMatrix() { const e = this.width / this.height, t = this.near * Math.tan(Math.PI / 180 * .5 * this.fov), s = 2 * t, i = e * s, r = -.5 * i, a = r + i, n = t - s, o = 2 * this.near / (a - r), h = 2 * this.near / (t - n), l = (a + r) / (a - r), d = (t + n) / (t - n), u = -(this.far + this.near) / (this.far - this.near), c = -2 * this.far * this.near / (this.far - this.near); this.projectionMatrix.setFromArray([o, 0, 0, 0, 0, h, 0, 0, l, d, u, -1, 0, 0, c, 0]) } forceUpdate() { this._shouldUpdate = !0 } cancelUpdate() { this._shouldUpdate = !1 } } class V { constructor(e = new Float32Array([0, 0, 0, 1]), t = "XYZ") { this.type = "Quat", this.elements = e, this.axisOrder = t } setFromArray(e) { return this.elements[0] = e[0], this.elements[1] = e[1], this.elements[2] = e[2], this.elements[3] = e[3], this } setAxisOrder(e) { switch (e = e.toUpperCase()) { case "XYZ": case "YXZ": case "ZXY": case "ZYX": case "YZX": case "XZY": this.axisOrder = e; break; default: this.axisOrder = "XYZ" }return this } copy(e) { return this.elements = e.elements, this.axisOrder = e.axisOrder, this } clone() { return (new V).copy(this) } equals(e) { return this.elements[0] === e.elements[0] && this.elements[1] === e.elements[1] && this.elements[2] === e.elements[2] && this.elements[3] === e.elements[3] && this.axisOrder === e.axisOrder } setFromVec3(e) { const t = .5 * e.x, s = .5 * e.y, i = .5 * e.z, r = Math.cos(t), a = Math.cos(s), n = Math.cos(i), o = Math.sin(t), h = Math.sin(s), l = Math.sin(i); return "XYZ" === this.axisOrder ? (this.elements[0] = o * a * n + r * h * l, this.elements[1] = r * h * n - o * a * l, this.elements[2] = r * a * l + o * h * n, this.elements[3] = r * a * n - o * h * l) : "YXZ" === this.axisOrder ? (this.elements[0] = o * a * n + r * h * l, this.elements[1] = r * h * n - o * a * l, this.elements[2] = r * a * l - o * h * n, this.elements[3] = r * a * n + o * h * l) : "ZXY" === this.axisOrder ? (this.elements[0] = o * a * n - r * h * l, this.elements[1] = r * h * n + o * a * l, this.elements[2] = r * a * l + o * h * n, this.elements[3] = r * a * n - o * h * l) : "ZYX" === this.axisOrder ? (this.elements[0] = o * a * n - r * h * l, this.elements[1] = r * h * n + o * a * l, this.elements[2] = r * a * l - o * h * n, this.elements[3] = r * a * n + o * h * l) : "YZX" === this.axisOrder ? (this.elements[0] = o * a * n + r * h * l, this.elements[1] = r * h * n + o * a * l, this.elements[2] = r * a * l - o * h * n, this.elements[3] = r * a * n - o * h * l) : "XZY" === this.axisOrder && (this.elements[0] = o * a * n - r * h * l, this.elements[1] = r * h * n - o * a * l, this.elements[2] = r * a * l + o * h * n, this.elements[3] = r * a * n + o * h * l), this } } const B = new S, W = new M, N = new M, H = new M, j = new M, G = new M, X = new M, Y = new M, q = new M, $ = new V, Z = new M(.5, .5, 0), Q = new M, J = new M, K = new M, ee = new M, te = new S; class se extends L { constructor(e, t, { widthSegments: s, heightSegments: i, renderOrder: r, depthTest: a, cullFace: n, uniforms: o, vertexShaderID: h, fragmentShaderID: l, vertexShader: d, fragmentShader: u, texturesOptions: c, crossOrigin: p, alwaysDraw: m = !1, visible: g = !0, transparent: f = !1, drawCheckMargins: _ = { top: 0, right: 0, bottom: 0, left: 0 }, autoloadSources: x = !0, watchScroll: v = !0, fov: y = 50 } = {}) { super(e, t, "Plane", { widthSegments: s, heightSegments: i, renderOrder: r, depthTest: a, cullFace: n, uniforms: o, vertexShaderID: h, fragmentShaderID: l, vertexShader: d, fragmentShader: u, texturesOptions: c, crossOrigin: p }), this.gl && (this.index = this.renderer.planes.length, this.target = null, this.alwaysDraw = m, this._shouldDraw = !0, this.visible = g, this._transparent = f, this.drawCheckMargins = _, this.autoloadSources = x, this.watchScroll = v, this._updateMVMatrix = !1, this.camera = new U({ fov: y, width: this.renderer._boundingRect.width, height: this.renderer._boundingRect.height, pixelRatio: this.renderer.pixelRatio }), this._program.compiled && (this._initPlane(), this.renderer.scene.addPlane(this), this.renderer.planes.push(this))) } _programRestored() { this.target && this.setRenderTarget(this.renderer.renderTargets[this.target.index]), this._initMatrices(), this.setPerspective(this.camera.fov, this.camera.near, this.camera.far), this._setWorldSizes(), this._applyWorldPositions(), this.renderer.scene.addPlane(this); for (let e = 0; e < this.textures.length; e++)this.textures[e]._parent = this, this.textures[e]._restoreContext(); this._canDraw = !0 } _initPlane() { this._initTransformValues(), this._initPositions(), this.setPerspective(this.camera.fov, this.camera.near, this.camera.far), this._initSources() } _initTransformValues() { this.rotation = new M, this.rotation.onChange(() => this._applyRotation()), this.quaternion = new V, this.relativeTranslation = new M, this.relativeTranslation.onChange(() => this._setTranslation()), this._translation = new M, this.scale = new M(1), this.scale.onChange(() => { this.scale.z = 1, this._applyScale() }), this.transformOrigin = new M(.5, .5, 0), this.transformOrigin.onChange(() => { this._setWorldTransformOrigin(), this._updateMVMatrix = !0 }) } resetPlane(e) { this._initTransformValues(), this._setWorldTransformOrigin(), null !== e && e ? (this.htmlElement = e, this.resize()) : e || this.renderer.production || r(this.type + ": You are trying to reset a plane with a HTML element that does not exist. The old HTML element will be kept instead.") } removeRenderTarget() { this.target && (this.renderer.scene.removePlane(this), this.target = null, this.renderer.scene.addPlane(this)) } _initPositions() { this._initMatrices(), this._setWorldSizes(), this._applyWorldPositions() } _initMatrices() { const e = new R; this._matrices = { world: { matrix: e }, modelView: { name: "uMVMatrix", matrix: e, location: this.gl.getUniformLocation(this._program.program, "uMVMatrix") }, projection: { name: "uPMatrix", matrix: e, location: this.gl.getUniformLocation(this._program.program, "uPMatrix") }, modelViewProjection: { matrix: e } } } _setPerspectiveMatrix() { this.camera._shouldUpdate && (this.renderer.useProgram(this._program), this.gl.uniformMatrix4fv(this._matrices.projection.location, !1, this._matrices.projection.matrix.elements)), this.camera.cancelUpdate() } setPerspective(e, t, s) { this.camera.setPerspective(e, t, s, this.renderer._boundingRect.width, this.renderer._boundingRect.height, this.renderer.pixelRatio), this.renderer.state.isContextLost && this.camera.forceUpdate(), this._matrices.projection.matrix = this.camera.projectionMatrix, this.camera._shouldUpdate && (this._setWorldSizes(), this._applyWorldPositions(), this._translation.z = this.relativeTranslation.z / this.camera.CSSPerspective), this._updateMVMatrix = this.camera._shouldUpdate } _setMVMatrix() { this._updateMVMatrix && (this._matrices.world.matrix = this._matrices.world.matrix.composeFromOrigin(this._translation, this.quaternion, this.scale, this._boundingRect.world.transformOrigin), this._matrices.world.matrix.scale({ x: this._boundingRect.world.width, y: this._boundingRect.world.height, z: 1 }), this._matrices.modelView.matrix.copy(this._matrices.world.matrix), this._matrices.modelView.matrix.elements[14] -= this.camera.position.z, this._matrices.modelViewProjection.matrix = this._matrices.projection.matrix.multiply(this._matrices.modelView.matrix), this.alwaysDraw || this._shouldDrawCheck(), this.renderer.useProgram(this._program), this.gl.uniformMatrix4fv(this._matrices.modelView.location, !1, this._matrices.modelView.matrix.elements)), this._updateMVMatrix = !1 } _setWorldTransformOrigin() { this._boundingRect.world.transformOrigin = new M((2 * this.transformOrigin.x - 1) * this._boundingRect.world.width, -(2 * this.transformOrigin.y - 1) * this._boundingRect.world.height, this.transformOrigin.z) } _documentToWorldSpace(e) { return N.set(e.x * this.renderer.pixelRatio / this.renderer._boundingRect.width * this._boundingRect.world.ratios.width, -e.y * this.renderer.pixelRatio / this.renderer._boundingRect.height * this._boundingRect.world.ratios.height, e.z) } _setWorldSizes() { const e = this.camera.getScreenRatiosFromFov(); this._boundingRect.world = { width: this._boundingRect.document.width / this.renderer._boundingRect.width * e.width / 2, height: this._boundingRect.document.height / this.renderer._boundingRect.height * e.height / 2, ratios: e }, this._setWorldTransformOrigin() } _setWorldPosition() { const e = this._boundingRect.document.width / 2 + this._boundingRect.document.left, t = this._boundingRect.document.height / 2 + this._boundingRect.document.top, s = this.renderer._boundingRect.width / 2 + this.renderer._boundingRect.left, i = this.renderer._boundingRect.height / 2 + this.renderer._boundingRect.top; this._boundingRect.world.top = (i - t) / this.renderer._boundingRect.height * this._boundingRect.world.ratios.height, this._boundingRect.world.left = (e - s) / this.renderer._boundingRect.width * this._boundingRect.world.ratios.width } setScale(e) { e.type && "Vec2" === e.type ? (e.sanitizeNaNValuesWith(this.scale).max(B.set(.001, .001)), e.x === this.scale.x && e.y === this.scale.y || (this.scale.set(e.x, e.y, 1), this._applyScale())) : this.renderer.production || r(this.type + ": Cannot set scale because the parameter passed is not of Vec2 type:", e) } _applyScale() { for (let e = 0; e < this.textures.length; e++)this.textures[e].resize(); this._updateMVMatrix = !0 } setRotation(e) { e.type && "Vec3" === e.type ? (e.sanitizeNaNValuesWith(this.rotation), e.equals(this.rotation) || (this.rotation.copy(e), this._applyRotation())) : this.renderer.production || r(this.type + ": Cannot set rotation because the parameter passed is not of Vec3 type:", e) } _applyRotation() { this.quaternion.setFromVec3(this.rotation), this._updateMVMatrix = !0 } setTransformOrigin(e) { e.type && "Vec3" === e.type ? (e.sanitizeNaNValuesWith(this.transformOrigin), e.equals(this.transformOrigin) || (this.transformOrigin.copy(e), this._setWorldTransformOrigin(), this._updateMVMatrix = !0)) : this.renderer.production || r(this.type + ": Cannot set transform origin because the parameter passed is not of Vec3 type:", e) } _setTranslation() { let e = W.set(0, 0, 0); this.relativeTranslation.equals(e) || (e = this._documentToWorldSpace(this.relativeTranslation)), this._translation.set(this._boundingRect.world.left + e.x, this._boundingRect.world.top + e.y, this.relativeTranslation.z / this.camera.CSSPerspective), this._updateMVMatrix = !0 } setRelativeTranslation(e) { e.type && "Vec3" === e.type ? (e.sanitizeNaNValuesWith(this.relativeTranslation), e.equals(this.relativeTranslation) || (this.relativeTranslation.copy(e), this._setTranslation())) : this.renderer.production || r(this.type + ": Cannot set translation because the parameter passed is not of Vec3 type:", e) } _applyWorldPositions() { this._setWorldPosition(), this._setTranslation() } updatePosition() { this._setDocumentSizes(), this._applyWorldPositions() } updateScrollPosition(e, t) { (e || t) && (this._boundingRect.document.top += t * this.renderer.pixelRatio, this._boundingRect.document.left += e * this.renderer.pixelRatio, this._applyWorldPositions()) } _getIntersection(e, t) { let s = t.clone().sub(e), i = e.clone(); for (; i.z > -1;)i.add(s); return i } _getNearPlaneIntersections(e, t, s) { const i = this._matrices.modelViewProjection.matrix; if (1 === s.length) 0 === s[0] ? (t[0] = this._getIntersection(t[1], Y.set(.95, 1, 0).applyMat4(i)), t.push(this._getIntersection(t[3], q.set(-1, -.95, 0).applyMat4(i)))) : 1 === s[0] ? (t[1] = this._getIntersection(t[0], Y.set(-.95, 1, 0).applyMat4(i)), t.push(this._getIntersection(t[2], q.set(1, -.95, 0).applyMat4(i)))) : 2 === s[0] ? (t[2] = this._getIntersection(t[3], Y.set(-.95, -1, 0).applyMat4(i)), t.push(this._getIntersection(t[1], q.set(1, .95, 0).applyMat4(i)))) : 3 === s[0] && (t[3] = this._getIntersection(t[2], Y.set(.95, -1, 0).applyMat4(i)), t.push(this._getIntersection(t[0], q.set(-1, .95, 0).applyMat4(i)))); else if (2 === s.length) 0 === s[0] && 1 === s[1] ? (t[0] = this._getIntersection(t[3], Y.set(-1, -.95, 0).applyMat4(i)), t[1] = this._getIntersection(t[2], q.set(1, -.95, 0).applyMat4(i))) : 1 === s[0] && 2 === s[1] ? (t[1] = this._getIntersection(t[0], Y.set(-.95, 1, 0).applyMat4(i)), t[2] = this._getIntersection(t[3], q.set(-.95, -1, 0).applyMat4(i))) : 2 === s[0] && 3 === s[1] ? (t[2] = this._getIntersection(t[1], Y.set(1, .95, 0).applyMat4(i)), t[3] = this._getIntersection(t[0], q.set(-1, .95, 0).applyMat4(i))) : 0 === s[0] && 3 === s[1] && (t[0] = this._getIntersection(t[1], Y.set(.95, 1, 0).applyMat4(i)), t[3] = this._getIntersection(t[2], q.set(.95, -1, 0).applyMat4(i))); else if (3 === s.length) { let r = 0; for (let t = 0; t < e.length; t++)s.includes(t) || (r = t); t = [t[r]], 0 === r ? (t.push(this._getIntersection(t[0], Y.set(-.95, 1, 0).applyMat4(i))), t.push(this._getIntersection(t[0], q.set(-1, .95, 0).applyMat4(i)))) : 1 === r ? (t.push(this._getIntersection(t[0], Y.set(.95, 1, 0).applyMat4(i))), t.push(this._getIntersection(t[0], q.set(1, .95, 0).applyMat4(i)))) : 2 === r ? (t.push(this._getIntersection(t[0], Y.set(.95, -1, 0).applyMat4(i))), t.push(this._getIntersection(t[0], q.set(1, -.95, 0).applyMat4(i)))) : 3 === r && (t.push(this._getIntersection(t[0], Y.set(-.95, -1, 0).applyMat4(i))), t.push(this._getIntersection(t[0], q.set(-1.95, 0).applyMat4(i)))) } else for (let r = 0; r < e.length; r++)t[r][0] = 1e4, t[r][1] = 1e4; return t } _getWorldCoords() { const e = [H.set(-1, 1, 0), j.set(1, 1, 0), G.set(1, -1, 0), X.set(-1, -1, 0)]; let t = [], s = []; for (let o = 0; o < e.length; o++) { const i = e[o].applyMat4(this._matrices.modelViewProjection.matrix); t.push(i), Math.abs(i.z) > 1 && s.push(o) } s.length && (t = this._getNearPlaneIntersections(e, t, s)); let i = 1 / 0, r = -1 / 0, a = 1 / 0, n = -1 / 0; for (let o = 0; o < t.length; o++) { const e = t[o]; e.x < i && (i = e.x), e.x > r && (r = e.x), e.y < a && (a = e.y), e.y > n && (n = e.y) } return { top: n, right: r, bottom: a, left: i } } _computeWebGLBoundingRect() { const e = this._getWorldCoords(); let t = { top: 1 - (e.top + 1) / 2, right: (e.right + 1) / 2, bottom: 1 - (e.bottom + 1) / 2, left: (e.left + 1) / 2 }; t.width = t.right - t.left, t.height = t.bottom - t.top, this._boundingRect.worldToDocument = { width: t.width * this.renderer._boundingRect.width, height: t.height * this.renderer._boundingRect.height, top: t.top * this.renderer._boundingRect.height + this.renderer._boundingRect.top, left: t.left * this.renderer._boundingRect.width + this.renderer._boundingRect.left, right: t.left * this.renderer._boundingRect.width + this.renderer._boundingRect.left + t.width * this.renderer._boundingRect.width, bottom: t.top * this.renderer._boundingRect.height + this.renderer._boundingRect.top + t.height * this.renderer._boundingRect.height } } getWebGLBoundingRect() { return this._matrices.modelViewProjection ? (this._boundingRect.worldToDocument && !this.alwaysDraw || this._computeWebGLBoundingRect(), this._boundingRect.worldToDocument) : this._boundingRect.document } _getWebGLDrawRect() { return this._computeWebGLBoundingRect(), { top: this._boundingRect.worldToDocument.top - this.drawCheckMargins.top, right: this._boundingRect.worldToDocument.right + this.drawCheckMargins.right, bottom: this._boundingRect.worldToDocument.bottom + this.drawCheckMargins.bottom, left: this._boundingRect.worldToDocument.left - this.drawCheckMargins.left } } _shouldDrawCheck() { const e = this._getWebGLDrawRect(); Math.round(e.right) <= this.renderer._boundingRect.left || Math.round(e.left) >= this.renderer._boundingRect.left + this.renderer._boundingRect.width || Math.round(e.bottom) <= this.renderer._boundingRect.top || Math.round(e.top) >= this.renderer._boundingRect.top + this.renderer._boundingRect.height ? this._shouldDraw && (this._shouldDraw = !1, this.renderer.nextRender.add(() => this._onLeaveViewCallback && this._onLeaveViewCallback())) : (this._shouldDraw || this.renderer.nextRender.add(() => this._onReEnterViewCallback && this._onReEnterViewCallback()), this._shouldDraw = !0) } isDrawn() { return this._canDraw && this.visible && (this._shouldDraw || this.alwaysDraw) } enableDepthTest(e) { this._depthTest = e } _initSources() { let e = 0; if (this.autoloadSources) { const t = this.htmlElement.getElementsByTagName("img"), s = this.htmlElement.getElementsByTagName("video"), i = this.htmlElement.getElementsByTagName("canvas"); t.length && this.loadImages(t), s.length && this.loadVideos(s), i.length && this.loadCanvases(i), e = t.length + s.length + i.length } this.loader._setLoaderSize(e), this._canDraw = !0 } _startDrawing() { this._canDraw && (this._onRenderCallback && this._onRenderCallback(), this.target ? this.renderer.bindFrameBuffer(this.target) : null === this.renderer.state.scenePassIndex && this.renderer.bindFrameBuffer(null), this._setPerspectiveMatrix(), this._setMVMatrix(), (this.alwaysDraw || this._shouldDraw) && this.visible && this._draw()) } mouseToPlaneCoords(e) { if ($.setAxisOrder(this.quaternion.axisOrder), $.equals(this.quaternion) && Z.equals(this.transformOrigin)) return super.mouseToPlaneCoords(e); { const t = { x: e.x / (this.renderer._boundingRect.width / this.renderer.pixelRatio) * 2 - 1, y: 2 * (1 - e.y / (this.renderer._boundingRect.height / this.renderer.pixelRatio)) - 1 }, s = this.camera.position.clone(), i = Q.set(t.x, t.y, -.5); i.unproject(this.camera), i.sub(s).normalize(); const r = J.set(0, 0, -1); r.applyQuat(this.quaternion).normalize(); const a = ee.set(0, 0, 0), n = r.dot(i); if (Math.abs(n) >= 1e-4) { const e = this._matrices.world.matrix.getInverse().multiply(this.camera.viewMatrix), t = this._boundingRect.world.transformOrigin.clone().add(this._translation), o = K.set(this._translation.x - t.x, this._translation.y - t.y, this._translation.z - t.z); o.applyQuat(this.quaternion), t.add(o); const h = r.dot(t.clone().sub(s)) / n; a.copy(s.add(i.multiplyScalar(h))), a.applyMat4(e) } else a.set(1 / 0, 1 / 0, 1 / 0); return te.set(a.x, a.y) } } onReEnterView(e) { return e && (this._onReEnterViewCallback = e), this } onLeaveView(e) { return e && (this._onLeaveViewCallback = e), this } } class ie { constructor(e, { shaderPass: t, depth: s = !1, clear: i = !0, maxWidth: r, maxHeight: o, minWidth: h = 1024, minHeight: l = 1024, texturesOptions: d = {} } = {}) { if (this.type = "RenderTarget", (e = e && e.renderer || e) && "Renderer" === e.type) { if (!e.gl) return void (e.production || a(this.type + ": Unable to create a " + this.type + " because the Renderer WebGL context is not defined")) } else a(this.type + ": Renderer not passed as first argument", e); this.renderer = e, this.gl = this.renderer.gl, this.index = this.renderer.renderTargets.length, this._shaderPass = t, this._depth = s, this._shouldClear = i, this._maxSize = { width: r ? Math.min(this.renderer.state.maxTextureSize / 4, r) : this.renderer.state.maxTextureSize / 4, height: o ? Math.min(this.renderer.state.maxTextureSize / 4, o) : this.renderer.state.maxTextureSize / 4 }, this._minSize = { width: h * this.renderer.pixelRatio, height: l * this.renderer.pixelRatio }, d = Object.assign({ sampler: "uRenderTexture", isFBOTexture: !0, premultiplyAlpha: !1, anisotropy: 1, generateMipmap: !1, floatingPoint: "none", wrapS: this.gl.CLAMP_TO_EDGE, wrapT: this.gl.CLAMP_TO_EDGE, minFilter: this.gl.LINEAR, magFilter: this.gl.LINEAR }, d), this._texturesOptions = d, this.userData = {}, this.uuid = n(), this.renderer.renderTargets.push(this), this.renderer.onSceneChange(), this._initRenderTarget() } _initRenderTarget() { this._setSize(), this.textures = [], this._createFrameBuffer() } _restoreContext() { this._setSize(), this._createFrameBuffer() } _setSize() { this._shaderPass && this._shaderPass._isScenePass ? this._size = { width: this.renderer._boundingRect.width, height: this.renderer._boundingRect.height } : this._size = { width: Math.min(this._maxSize.width, Math.max(this._minSize.width, this.renderer._boundingRect.width)), height: Math.min(this._maxSize.height, Math.max(this._minSize.height, this.renderer._boundingRect.height)) } } resize() { this._shaderPass && (this._setSize(), this.textures[0].resize(), this.renderer.bindFrameBuffer(this, !0), this._depth && this._bindDepthBuffer(), this.renderer.bindFrameBuffer(null)) } _bindDepthBuffer() { this._depthBuffer && (this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this._depthBuffer), this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this._size.width, this._size.height), this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this._depthBuffer)) } _createFrameBuffer() { if (this._frameBuffer = this.gl.createFramebuffer(), this.renderer.bindFrameBuffer(this, !0), this.textures.length) this.textures[0]._parent = this, this.textures[0]._restoreContext(); else { new A(this.renderer, this._texturesOptions).addParent(this) } this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.textures[0]._sampler.texture, 0), this._depth && (this._depthBuffer = this.gl.createRenderbuffer(), this._bindDepthBuffer()), this.renderer.bindFrameBuffer(null) } getTexture() { return this.textures[0] } remove() { this._shaderPass ? this.renderer.production || r(this.type + ": You're trying to remove a RenderTarget attached to a ShaderPass. You should remove that ShaderPass instead:", this._shaderPass) : (this._dispose(), this.renderer.removeRenderTarget(this)) } _dispose() { this._frameBuffer && (this.gl.deleteFramebuffer(this._frameBuffer), this._frameBuffer = null), this._depthBuffer && (this.gl.deleteRenderbuffer(this._depthBuffer), this._depthBuffer = null), this.textures[0]._dispose(), this.textures = [] } } class re extends se { constructor(e, t, { sampler: s = "uPingPongTexture", widthSegments: i, heightSegments: r, renderOrder: a, depthTest: n, cullFace: o, uniforms: h, vertexShaderID: l, fragmentShaderID: d, vertexShader: u, fragmentShader: c, texturesOptions: p, crossOrigin: m, alwaysDraw: g, visible: f, transparent: _, drawCheckMargins: x, autoloadSources: v, watchScroll: y, fov: b } = {}) { if (super(e, t, { widthSegments: i, heightSegments: r, renderOrder: a, depthTest: false, cullFace: o, uniforms: h, vertexShaderID: l, fragmentShaderID: d, vertexShader: u, fragmentShader: c, texturesOptions: p, crossOrigin: m, alwaysDraw: g, visible: f, transparent: _, drawCheckMargins: x, autoloadSources: false, watchScroll: y, fov: b }), !this.gl) return; this.renderer.scene.removePlane(this), this.type = "PingPongPlane", this.renderer.scene.addPlane(this), this.readPass = new ie(e, { depth: !1, clear: !1, texturesOptions: p }), this.writePass = new ie(e, { depth: !1, clear: !1, texturesOptions: p }), this.createTexture({ sampler: s }); let P = 0; this.readPass.getTexture().onSourceUploaded(() => { P++, this._checkIfReady(P) }), this.writePass.getTexture().onSourceUploaded(() => { P++, this._checkIfReady(P) }), this.setRenderTarget(this.readPass), this._onRenderCallback = () => { this.readPass && this.writePass && this.textures[0] && this.textures[0]._uploaded && this.setRenderTarget(this.writePass), this._onPingPongRenderCallback && this._onPingPongRenderCallback() }, this._onAfterRenderCallback = () => { this.readPass && this.writePass && this.textures[0] && this.textures[0]._uploaded && this._swapPasses(), this._onPingPongAfterRenderCallback && this._onPingPongAfterRenderCallback() } } _checkIfReady(e) { 2 === e && this.renderer.nextRender.add(() => { this.textures[0].copy(this.target.getTexture()) }) } _swapPasses() { const e = this.readPass; this.readPass = this.writePass, this.writePass = e, this.textures[0].copy(this.readPass.getTexture()) } getTexture() { return this.textures[0] } onRender(e) { return e && (this._onPingPongRenderCallback = e), this } onAfterRender(e) { return e && (this._onPingPongAfterRenderCallback = e), this } remove() { this.target = null, this.renderer.bindFrameBuffer(null), this.writePass && (this.writePass.remove(), this.writePass = null), this.readPass && (this.readPass.remove(), this.readPass = null), super.remove() } } let ae, ne, oe, he, le = !1, de = window.innerHeight || document.documentElement.clientHeight, ue = window.innerWidth || document.documentElement.clientWidth, ce = window.scrollY || window.pageYOffset, pe = 0, me = 0, ge = 0; const fe = .001; function _e(e) { return window.atob(e) } function xe() { return "id-" + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) } function ve(e, t, s, i, r) { if (s.length > 1) { let a, n = i ? 2 * +i * Math.PI : 0, o = t.width / 2, h = t.height / 2, l = t.width / 2, d = t.height / 2; if ("radial" === r) { const t = Math.max(l, d); a = e.createRadialGradient(o, h, t, o, h, 0) } const u = Math.cos(n) * l, c = Math.sin(n) * d; if ("linear" === r && (a = e.createLinearGradient(o - u, h - c, o + u, h + c)), "conic" === r) { a = e.createConicGradient(-Math.PI + n, o, h); const t = [...s, ...s.slice().reverse()]; t.forEach((e, s) => { a.addColorStop(s * (1 / (t.length - 1)), e) }) } else s.forEach((e, t) => { a.addColorStop(t * (1 / (s.length - 1)), e) }); return a } return s[0] } function ye(e) { const t = { linear: e => e, easeInQuad: e => e * e, easeOutQuad: e => 1 - (1 - e) * (1 - e), easeInOutQuad: e => e < .5 ? 2 * e * e : 1 - Math.pow(-2 * e + 2, 2) / 2, easeInCubic: e => e * e * e, easeOutCubic: e => 1 - Math.pow(1 - e, 3), easeInOutCubic: e => e < .5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2, easeInQuart: e => e ** 4, easeOutQuart: e => 1 - Math.pow(1 - e, 4), easeInOutQuart: e => e < .5 ? 8 * e ** 4 : 1 - Math.pow(-2 * e + 2, 4) / 2, easeInQuint: e => e ** 5, easeOutQuint: e => 1 - Math.pow(1 - e, 5), easeInOutQuint: e => e < .5 ? 16 * e ** 5 : 1 - Math.pow(-2 * e + 2, 5) / 2, easeOutElastic: e => { const t = 2 * Math.PI / 3; return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin((10 * e - .75) * t) + 1 }, easeInElastic: e => { const t = 2 * Math.PI / 3; return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * e - 10) * Math.sin((10 * e - 10.75) * t) }, easeInOutElastic: e => { const t = 2 * Math.PI / 4.5; return 0 === e ? 0 : 1 === e ? 1 : e < .5 ? -Math.pow(2, 20 * e - 10) * Math.sin((20 * e - 11.125) * t) / 2 : Math.pow(2, -20 * e + 10) * Math.sin((20 * e - 11.125) * t) / 2 + 1 }, easeInSine: e => 1 - Math.cos(e * Math.PI / 2), easeOutSine: e => Math.sin(e * Math.PI / 2), easeInOutSine: e => -(Math.cos(Math.PI * e) - 1) / 2, easeInCirc: e => 1 - Math.sqrt(1 - e ** 2), easeOutCirc: e => Math.sqrt(1 - Math.pow(e - 1, 2)), easeInOutCirc: e => e < .5 ? (1 - Math.sqrt(1 - (2 * e) ** 2)) / 2 : (Math.sqrt(1 - Math.pow(-2 * e + 2, 2)) + 1) / 2, easeInExpo: e => 0 === e ? 0 : Math.pow(2, 10 * e - 10), easeOutExpo: e => 1 === e ? 1 : 1 - Math.pow(2, -10 * e), easeInOutExpo: e => 0 === e ? 0 : 1 === e ? 1 : e < .5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2, easeInBack: e => { const t = 1.70158; return (t + 1) * e * e * e - t * e * e }, easeOutBack: e => { const t = 1.70158; return 1 + (t + 1) * Math.pow(e - 1, 3) + t * Math.pow(e - 1, 2) }, easeInOutBack: e => { const t = 2.5949095; return e < .5 ? Math.pow(2 * e, 2) * (7.189819 * e - t) / 2 : (Math.pow(2 * e - 2, 2) * ((t + 1) * (2 * e - 2) + t) + 2) / 2 } }; if (t[e]) return t[e]; if ("string" == typeof e && (e.includes("=>") || e.includes("function") || e.includes("x"))) { const t = new Function("return " + e)(); if (t) return t } return t.linear } function be(e) { return e && "string" == typeof e && (e = JSON.parse(e)), Object.values(e) } function Pe(e, t, s) { for (let i = 0; i < s; i++)e = (e + t) / 2; return +((e + t) / 2).toFixed(4) } function we() { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) } function Te(e, t) { return e.getAttribute(t) } function Re(e) { if (void 0 !== e.local.isDynamicCache) return e.local.isDynamicCache; const t = ["trackMouse", "axisTilt", "trackMouseMove", "rotationTracking", "lightTracking"].some(t => e.hasOwnProperty(t) && 0 !== e[t]), s = e.states && [...e.states.appear, ...e.states.scroll, ...e.states.hover].length > 0, i = ("effect" === e.layerType || e.isModel) && (e.animating || e.usesPingPong), r = "video" === e.type, a = t || s || i || r; return e.local.isDynamicCache = a, a } function Se(e, t) { if (e.noTextAsHtml) return; if (!t) return; let s = "fixed" === e.widthMode ? e.width : e.width * t.offsetWidth, i = e.height, r = "fixed" === e.fontSizeMode ? e.fontSize : e.fontSize * t.offsetWidth, a = "fixed" === e.fontSizeMode ? e.lineHeight : e.lineHeight * r, n = "fixed" === e.fontSizeMode ? e.letterSpacing : e.letterSpacing * r, o = "fixed" === e.topMode ? e.top : e.top * t.offsetHeight, h = "fixed" === e.leftMode ? e.left : e.left * t.offsetWidth, l = Le(e.anchorPoint); h -= l.x * s, o -= l.y * i, o += t.offsetTop, h += t.offsetLeft; const d = document.querySelector(`[data-us-text="${e.local.id}"]`), u = d || document.createElement("div"); u.setAttribute("data-us-text", e.local.id), u.style.cssText = `width:${s}px;top:${o}px;left:${h}px;font-size:${r}px;line-height:${a}px;letter-spacing:${n}px;font-family:${e.fontFamily};font-weight:${e.fontWeight};text-align:${e.textAlign};position:absolute;word-break:break-word;transform:rotateZ(${Math.round(360 * e.rotation)}deg);color:transparent;z-index:2;`, u.innerText = e.textContent, d || t.appendChild(u) } function Me() { Qe.filter(e => !document.body.contains(e.element)).forEach(e => { e.curtain && e.curtain.dispose(); const t = Qe.indexOf(e); -1 !== t && Qe.splice(t, 1) }) } function Ee() { cancelAnimationFrame(oe); let e = Qe.filter(e => !e.destroyed && e.getDynamicLayers().length > 0); const t = s => { let i = !1; e.forEach(e => { e.destroyed || (e.isInView && e.initialized ? (e.rendering = !0, s - (e.lastTime || 0) >= e.frameDuration && !e.paused && (e.renderFrame(), e.lastTime = s), i = !0) : e.rendering = !1) }), (!ge || s - ge > 64) && (ce = window.scrollY || window.pageYOffset, me = ce - pe, pe = ce, ge = s, (me > 1e3 || me < 0 && !pe && !ce) && Ye()), i ? (!function () { let e = performance.now(); Qe.forEach(t => { var s, i, r, a, n, o; if (t.isInView && (null == (i = null == (s = t.curtain) ? void 0 : s.planes) ? void 0 : i.find(e => e.uniforms.mousePos))) if (we() && (null == (a = null == (r = t.interactivity) ? void 0 : r.mouse) ? void 0 : a.disableMobile) || (null == (o = null == (n = t.interactivity) ? void 0 : n.mouse) ? void 0 : o.disabled)); else { t.mouse.pos.y = t.mouse.movePos.y, t.mouse.pos.x = t.mouse.movePos.x, t.mouse.lastPos.x = t.mouse.pos.x, t.mouse.lastPos.y = t.mouse.pos.y; let s = t.isFixed ? t.bbox.top : t.bbox.top + t.scrollY, i = t.bbox.left; t.mouse.page.x > i && t.mouse.page.y > s && t.mouse.page.x < t.lastBbox.width + i && t.mouse.page.y < t.lastBbox.height + s ? t.mouse.enterTime || (t.mouse.enterTime = e) : t.mouse.enterTime = null } }) }(), oe = requestAnimationFrame(t)) : cancelAnimationFrame(oe) }; e.length ? oe = requestAnimationFrame(t) : cancelAnimationFrame(oe) } function Ce(e, t, s) { return "Vec3" === (null == e ? void 0 : e.type) && "Vec3" === (null == t ? void 0 : t.type) ? { type: "Vec3", x: e._x + (t._x - e._x) * s, y: e._y + (t._y - e._y) * s, z: e._z + (t._z - e._z) * s } : "Vec2" === (null == e ? void 0 : e.type) && "Vec2" === (null == t ? void 0 : t.type) ? { type: "Vec2", x: e._x + (t._x - e._x) * s, y: e._y + (t._y - e._y) * s } : e + (t - e) * s } function ke(e, t) { return "Vec2" === e.type ? e = new S(e._x, e._y) : "Vec3" === e.type && (e = new M(e._x, e._y, e._z)), e } function Ae(e, t, s) { (null == e ? void 0 : e.type) && ("Vec2" === (null == e ? void 0 : e.type) || "Vec3" === (null == e ? void 0 : e.type)) ? (t.value.x = e.x, t.value.y = "pos" === s ? 1 - e.y : e.y, "Vec3" === e.type && (t.value.z = e.z)) : t.value = e } function Fe(e, t, s) { e.createTexture({ sampler: t, premultiplyAlpha: !0, fromTexture: s }) } void 0 !== document.hidden ? (ae = "hidden", ne = "visibilitychange") : void 0 !== document.msHidden ? (ae = "msHidden", ne = "msvisibilitychange") : void 0 !== document.webkitHidden && (ae = "webkitHidden", ne = "webkitvisibilitychange"); class De { constructor({ prop: e, value: t, endValue: i, transition: r, breakpoints: a, uniformData: n, loop: o = "none", loopDelay: h = 0 }) { s(this, "id", xe()), this.prop = e, this.transition = r, this.complete = !1, this.progress = 0, this.uniformData = n, this.value = ke(t), this.endValue = void 0 !== i ? ke(i || 0) : null, this.lastTick = void 0, this.initialized = !1, this.startTime = null, this.breakpoints = a || [], this.loop = o, this.loopDelay = h, this.easeFunction = ye(this.transition.ease) } updateEffect(e, t) { if (void 0 === (e = this.endValue ?? e)) return !1; const s = performance.now(), i = s - ((this.startTime || t) + this.transition.delay); if (i < 0) return !1; if ("none" !== this.loop) { const t = this.transition.duration + this.loopDelay, r = i % t; if (r > this.transition.duration) return !1; const a = r / this.transition.duration, n = Math.floor(i / t); let o = a; return "reverse" === this.loop && n % 2 == 1 && (o = 1 - a), this.progress = this.easeFunction(o), this.lastTick = s, Ce(this.value, e, this.progress) } const r = Math.max(0, Math.min(1, i / this.transition.duration)); return this.progress = this.easeFunction(r), 0 !== this.progress && (r >= 1 ? (this.complete = !0, this.progress = 0, e) : (this.lastTick = s, !this.complete && Ce(this.value, e, this.progress))) } resetState() { this.progress = 0, this.complete = !1, this.lastTick = void 0, this.initialized = !1 } } class Ie { constructor({ prop: e, value: t, range: i, offset: r, momentum: a, uniformData: n, mode: o = "scrollIntoView", delta: h = .01, absScrollValue: l = !0, breakpoints: d = [] }) { s(this, "id", xe()), this.prop = e, this.progress = 0, this.momentum = a, this.range = i, this.offset = r, this.mode = o, this.delta = h, this.absScrollValue = l, this.uniformData = n, this.value = ke(t), this.lastTick = void 0, this.breakpoints = d || [] } updateEffect(e, { top: t, height: s, isFixed: i }) { if (void 0 === e) return !1; if (i && (t -= ce), "scrollIntoView" === this.mode) { const i = t + ce - de * this.offset, r = i + (de + s) * this.range; let a = (ce - i) / (r - i), n = Math.max(0, Math.min(1, a)); return !(void 0 !== this.lastTick && (n = Pe(n, this.lastTick, 2 * this.momentum), Math.abs(this.lastTick - n) < fe)) && (this.lastTick = n, Ce(e, this.value, n)) } if ("whileScrolling" === this.mode) { let t = me * this.delta; return this.absScrollValue && (t = Math.abs(t)), void 0 !== this.lastTick && (t = Pe(t, this.lastTick, 2 * this.momentum), Math.abs(t) < fe) ? !1 : (this.lastScrollPos = ce, this.lastTick = t, Ce(e, this.value, t)) } return !1 } resetState() { this.lastTick = void 0 } } class Oe { constructor({ prop: e, value: t, transition: i, breakpoints: r, uniformData: a, triggerOnElement: n }) { s(this, "id", xe()), this.prop = e, this.transition = i, this.progress = 0, this.rawProgress = 0, this.lastProgress = null, this.value = ke(t), this.uniformData = a, this.triggerOnElement = void 0 !== n ? n : 1, this.breakpoints = r || [], this.easeFunction = ye(this.transition.ease) } updateEffect(e, t, s) { var i; if (void 0 === e) return !1; const r = null == (i = null == s ? void 0 : s.getParent) ? void 0 : i.call(s), a = performance.now(); if (this.triggerOnElement && ((null == s ? void 0 : s.isElement) || r)) { let e = (r || s).isHovered(); t = e && !this.lastEnterTime ? a : e ? this.lastEnterTime : null } const n = null === t, o = (a - (n ? this.lastTick || a : t + this.transition.delay)) / this.transition.duration, h = Math.max(0, Math.min(1, o)); n ? this.rawProgress = Math.max(0, this.rawProgress - h) : (this.lastEnterTime !== t && (this.lastProgress = this.rawProgress || 0), this.rawProgress = Math.min(1, this.lastProgress + h)); const l = this.easeFunction(this.rawProgress), d = Math.abs(this.progress - l) > fe; return this.progress = l, !(!t && !d) && (!t && this.transition.forwardsOnly && (this.progress = 0, this.rawProgress = 0), this.lastTick = a, this.lastEnterTime = t, !!d && Ce(e, this.value, this.progress)) } resetState() { this.progress = 0 } } class ze { constructor(e, t, i) { var r; s(this, "local", { id: "", projectId: "", lastMousePos: { x: .5, y: .5 }, createdAt: null }), this.initOptions = i, this.aspectRatio = e.aspectRatio || 1, this.layerName = e.layerName || e.id, this.data = e.data || {}, this.userDownsample = e.userDownsample || 1, this.breakpoints = ((r = e.breakpoints || []).forEach(e => { var t, s; for (let i in e.props) "Vec2" === (null == (t = e.props[i]) ? void 0 : t.type) ? e.props[i] = new S(e.props[i]._x, e.props[i]._y) : "Vec3" === (null == (s = e.props[i]) ? void 0 : s.type) ? e.props[i] = new M(e.props[i]._x, e.props[i]._y, e.props[i]._z) : "object" == typeof e.props[i] && (e.props[i] = be(e.props[i])) }), r), this.local.sceneId = t, this.local.id = xe(), this.id = e.id, this.compiledFragmentShaders = e.compiledFragmentShaders || [], this.compiledVertexShaders = e.compiledVertexShaders || [], this.states = { appear: e.states && e.states.appear ? e.states.appear.map(e => new De(e)) : [], scroll: e.states && e.states.scroll ? e.states.scroll.map(e => new Ie(e)) : [], hover: e.states && e.states.hover ? e.states.hover.map(e => new Oe(e)) : [] } } state() { return Qe.find(e => e.id === this.local.sceneId) || this.initOptions } getIndex() { return this.state().layers.map(e => e.local.id).indexOf(this.local.id) } getPixelRatio() { const e = this.state(); return e.dpi * e.scale * this.userDownsample } getPlane() { var e, t, s; return null == (s = null == (t = null == (e = this.state()) ? void 0 : e.curtain) ? void 0 : t.planes) ? void 0 : s.find(e => "PingPongPlane" !== e.type && e.userData.id === this.local.id) } getPlanes() { var e, t, s; return (null == (s = null == (t = null == (e = this.state()) ? void 0 : e.curtain) ? void 0 : t.planes) ? void 0 : s.filter(e => "PingPongPlane" !== e.type && e.userData.id === this.local.id)) || [] } getMaskedItem() { return !!this.mask && this.state().layers.filter(e => !e.parentLayer)[this.getIndex() - 1] } getChildEffectItems() { if (this.effects && this.effects.length) { const e = this.state(); if (!e || !e.layers) return []; const t = e.layers.filter(e => this.effects.includes(e.parentLayer)); return this.effects.map(e => t.find(t => t.parentLayer === e)).filter(e => void 0 !== e) } return [] } setBreakpointValues() { const e = ue, t = this.breakpoints.sort((e, t) => t.min - e.min), s = {}; if (1 === t.length && "Desktop" === t[0].name) return; if (t.length >= 1 && !t.find(e => "Desktop" === e.name)) throw new Error("Malfored breakpoint data, missing Desktop"); for (let r = t.length - 1; r >= 0; r--) { const i = t[r]; if (null === i.max || e <= i.max) for (let e in i.props) s.hasOwnProperty(e) || (s[e] = i.props[e]) } const i = this.breakpoints.find(e => "Desktop" === e.name); if (i) for (let r in i.props) s.hasOwnProperty(r) || (s[r] = i.props[r]); for (let r in s) if (this.hasOwnProperty(r)) { let e = s[r]; (null == e ? void 0 : e.type) ? (this[r].x = e._x, this[r].y = e._y, void 0 !== e._z && (this[r].z = e._z)) : this[r] = e } this.local.bpProps = s } updateStateEffects() { var e, t, s, i; if (!this.states.appear.some(e => !e.complete) && !(null == (e = this.states) ? void 0 : e.scroll.length) && !(null == (t = this.states) ? void 0 : t.hover.length) || this.isModel && !this.local.modelLoaded) return; this.local.uniformUpdatesPool || (this.local.uniformUpdatesPool = {}), this.local.updatedProps ? this.local.updatedProps.clear() : this.local.updatedProps = new Set, this.local.hasUpdates = !1; const r = this.state(); let a = performance.now(); this.local.cachedBreakpoint && this.local.cachedBreakpoint === (null == (s = r.currentBreakpoint) ? void 0 : s.name) || (this.local.cachedBreakpoint = null == (i = r.currentBreakpoint) ? void 0 : i.name); const n = e => !e.breakpoints || 0 === e.breakpoints.length || e.breakpoints.find(e => e === this.local.cachedBreakpoint); r.isInView && (null === this.local.createdAt && (this.local.createdAt = a), this.states.appear.forEach(e => { if (!n(e)) return; let t = e.startTime || this.local.createdAt; if (!e.initialized) { const s = [...this.states.appear.filter(t => t.prop === e.prop)].sort((e, t) => (e.transition.delay || 0) - (t.transition.delay || 0))[0]; (null == s ? void 0 : s.id) === e.id && (this.local.uniformUpdatesPool[e.prop] = e.value, this.local.hasUpdates = !0, this.local.updatedProps.add(e.prop)), e.initialized = !0, t || (e.startTime = a) } (null == r ? void 0 : r.pauseTime) && (t += Math.abs(null == r ? void 0 : r.pauseTime)); const s = e.updateEffect(this[e.prop], t); !1 !== s && (this.local.uniformUpdatesPool[e.prop] = s, this.local.hasUpdates = !0, this.local.updatedProps.add(e.prop)), this.isElement && e.complete && this.local.stateEffectProps && this.local.stateEffectProps[e.prop] && delete this.local.stateEffectProps[e.prop] })), this.states.hover.forEach(e => { if (!n(e)) return; const t = e.updateEffect(this[e.prop], r.mouse.enterTime, this); !1 !== t && (this.local.uniformUpdatesPool[e.prop] = t, this.local.hasUpdates = !0, this.local.updatedProps.add(e.prop)) }), this.states.scroll.forEach(e => { var t; if (!n(e)) return; const s = r.bbox; if (!s) return; const i = e.updateEffect(this[e.prop], { top: r.isFixed ? 0 : null == (t = r.bbox) ? void 0 : t.top, height: s.height / 2, isFixed: r.isFixed }); !1 !== i && (this.local.uniformUpdatesPool[e.prop] = i, this.local.hasUpdates = !0, this.local.updatedProps.add(e.prop)) }), this.local.hasUpdates && (this.getPlanes().forEach(e => { var t; for (let s of this.local.updatedProps) { const i = this.local.uniformUpdatesPool[s]; void 0 !== i && ((null == (t = e.uniforms[s]) ? void 0 : t.lastValue) !== i && (e.uniforms[s] && Ae(i, e.uniforms[s], s), this.updateStateEffectProperty(s, i))) } }), this.isElement && this.local.stateEffectProps && Object.keys(this.local.stateEffectProps).length && this.render()) } updateStateEffectProperty(e, t) { this.local.stateEffectProps || (this.local.stateEffectProps = {}), this.local.stateEffectProps[e] = t } invalidatePerformanceCaches() { this.local.isDynamicCache = void 0, this.local.cachedBreakpoint = void 0, this.local.lastCalculatedMousePos = void 0, this.local.lastCalculatedMouseValues = void 0 } dispose() { this.invalidatePerformanceCaches() } } function Le(e) { const t = { topLeft: { x: 0, y: 0 }, topCenter: { x: .5, y: 0 }, topRight: { x: 1, y: 0 }, rightCenter: { x: 1, y: .5 }, bottomRight: { x: 1, y: 1 }, bottomCenter: { x: .5, y: 1 }, bottomLeft: { x: 0, y: 1 }, leftCenter: { x: 0, y: .5 }, center: { x: .5, y: .5 } }; return t[e] || t.topLeft } let Ue = class extends ze { constructor(e, t) { super(e, t), s(this, "isElement", !0), this.anchorPoint = e.anchorPoint || "topLeft", this.opacity = e.opacity ?? 1, this.displace = e.displace || 0, this.effects = e.effects || [], this.trackMouse = e.trackMouse || 0, this.axisTilt = e.axisTilt || 0, this.trackAxes = e.trackAxes || "xy", this.bgDisplace = e.bgDisplace || 0, this.dispersion = e.dispersion || 0, this.rotation = e.rotation || 0, this.mouseMomentum = e.mouseMomentum || 0, this.maskAlpha = e.maskAlpha || 0, this.maskDepth = e.maskDepth || 0, this.maskDepthLayer = e.maskDepthLayer || 1, this.maskBackground = e.maskBackground || {}, this.mask = e.mask || 0, this.blendMode = e.blendMode || "NORMAL", this.width = e.width || 0, this.height = e.height || 0, this.widthMode = e.widthMode || "fixed", this.heightMode = e.heightMode || "fixed", this.left = e.left || 0, this.top = e.top || 0, this.leftMode = e.leftMode || "relative", this.topMode = e.topMode || "relative" } unpackage() { return this.effects = be(this.effects), this.maskBackground = new M(this.maskBackground._x, this.maskBackground._y, this.maskBackground._z), this.unpackageType(), this } createLocalCanvas() { const e = this.state(), t = document.createElement("canvas"), s = this.getPixelRatio(); t.width = e.canvasWidth * s, t.height = e.canvasHeight * s; const i = t.getContext("2d"); i.scale(s, s), this.local.canvas = t, this.local.ctx = i } resize() { var e, t; const s = this.state(); if (this.local.canvas) { const e = this.getPixelRatio(); this.local.canvas.width = s.canvasWidth * e, this.local.canvas.height = s.canvasHeight * e, this.local.ctx.scale(e, e) } (null == (t = null == (e = this.states) ? void 0 : e.appear) ? void 0 : t.some(e => !e.complete)) || this.render(), "text" === this.layerType && Se(this, this.state().element) } dispose() { this.local.canvas && (this.local.canvas.width = 1, this.local.canvas.height = 1, this.local.canvas = null), this.local.ctx && (this.local.ctx = null), super.dispose() } box() { const e = Le(this.anchorPoint), { width: t, height: s } = this.getAbsoluteDimensions(), { left: i, top: r } = this.getAbsolutePosition(); return { anchor: { x: i + t * (.5 - e.x), y: r + s * (.5 - e.y) }, center: { x: i + t / 2, y: r + s / 2 }, left: i, top: r, width: t, height: s } } getAbsolutePosition() { var e, t, s, i; const r = this.state(), a = r.canvasWidth, n = r.canvasHeight; let o = (null == (t = null == (e = this.local) ? void 0 : e.stateEffectProps) ? void 0 : t.left) ?? this.left, h = (null == (i = null == (s = this.local) ? void 0 : s.stateEffectProps) ? void 0 : i.top) ?? this.top, l = "fixed" === this.leftMode ? o : o * a, d = "fixed" === this.topMode ? h : h * n; return l = +l.toFixed(1), d = +d.toFixed(1), { left: l, top: d } } getAbsoluteDimensions() { var e, t, s, i; const r = this.state(); let a, n; const o = r.canvasWidth, h = r.canvasHeight; let l = (null == (t = null == (e = this.local) ? void 0 : e.stateEffectProps) ? void 0 : t.width) ?? this.width, d = (null == (i = null == (s = this.local) ? void 0 : s.stateEffectProps) ? void 0 : i.height) ?? this.height; return "auto" !== this.widthMode && (a = "fixed" === this.widthMode ? l : l * o, "auto" === this.heightMode && (n = a / (this.aspectRatio || 1), this.height = "fixed" === this.widthMode ? n : n / h)), "auto" !== this.heightMode && (n = "fixed" === this.heightMode ? d : d * h, "auto" === this.widthMode && (a = n * (this.aspectRatio || 1), this.width = "fixed" === this.widthMode ? a : a / o)), "text" === this.layerType && (n = this.height), { width: a, height: n } } isHovered() { let { left: e, top: t, width: s, height: i } = this.box(); const r = Le(this.anchorPoint); s < 0 && (s = Math.abs(s)), i < 0 && (t += i, i = Math.abs(i)), e -= r.x * s, t -= r.y * i; let a = this.state().mouse.movePos; return 2 * a.x >= e && 2 * a.x <= e + s && 2 * a.y >= t && 2 * a.y <= t + i } }; class Ve extends Ue { constructor(e, t, i) { super(e, t), s(this, "layerType", "shape"), s(this, "isElement", !0), this.initOptions = i; let r = this.default(e || {}); for (let s in r) this[s] = r[s]; this.breakpoints.length && this.setBreakpointValues(), Object.keys(e).length && this.createLocalCanvas() } default(e) { return { borderRadius: e.borderRadius || 0, fill: e.fill || ["#777777"], fitToCanvas: e.fitToCanvas || !1, gradientAngle: e.gradientAngle || e.gradAngle || 0, gradientType: e.gradientType || e.gradType || "linear", numSides: e.numSides || 3, type: e.type || "rectangle", stroke: e.stroke || ["#000000"], strokeWidth: e.strokeWidth || 0 } } unpackageType() { return this.fill = be(this.fill), this.stroke = be(this.stroke), this.render(), this } render() { var e, t, s, i; let r = this.local.ctx; const a = this.state(); let { left: n, top: o, width: h, height: l } = this.box(); const d = Le(this.anchorPoint); let u = (null == (e = this.local.stateEffectProps) ? void 0 : e.borderRadius) ?? this.borderRadius, c = (null == (t = this.local.stateEffectProps) ? void 0 : t.strokeWidth) ?? this.strokeWidth, p = (null == (s = this.local.stateEffectProps) ? void 0 : s.gradientAngle) ?? this.gradientAngle, m = (null == (i = this.local.stateEffectProps) ? void 0 : i.rotation) ?? this.rotation, g = n - d.x * h, f = o - d.y * l; if (r.clearRect(0, 0, a.canvasWidth, a.canvasHeight), r.beginPath(), this.fitToCanvas) r.rect(0, 0, a.canvasWidth, a.canvasHeight), r.fillStyle = ve(r, { width: a.canvasWidth, height: a.canvasHeight }, this.fill, p, this.gradientType); else { if (r.save(), r.translate(g + h / 2, f + l / 2), r.rotate(2 * m * Math.PI), r.translate(-h / 2, -l / 2), "rectangle" === this.type) { let e = u * Math.min(Math.abs(h), Math.abs(l)) / 2; this.drawRoundedRect(r, 0, 0, h, l, e) } else "circle" === this.type ? r.ellipse(h / 2, l / 2, Math.abs(h) / 2, Math.abs(l) / 2, 0, 0, 2 * Math.PI) : "polygon" === this.type && this.drawPolygon(r, Math.abs(h / 2), Math.abs(l / 2), this.numSides); r.fillStyle = ve(r, this.box(), this.fill, p, this.gradientType) } r.fill(), c && (r.strokeStyle = this.stroke[0], r.lineWidth = c, r.stroke()), r.restore() } drawRoundedRect(e, t, s, i, r, a) { e.beginPath(), e.moveTo(t + a, s), e.arcTo(t + i, s, t + i, s + r, a), e.arcTo(t + i, s + r, t, s + r, a), e.arcTo(t, s + r, t, s, a), e.arcTo(t, s, t + i, s, a), e.closePath() } drawPolygon(e, t, s, i) { e.beginPath(); for (let r = 0; r < i; r++) { const a = 2 * r * Math.PI / i - Math.PI / 2, n = t * Math.cos(a) + t, o = s * Math.sin(a) + s; 0 === r ? e.moveTo(n, o) : e.lineTo(n, o) } e.closePath() } } class Be extends ze { constructor(e, t, i) { super(e, t), s(this, "layerType", "effect"), this.initOptions = i, this.type = e.type || "sine", this.usesPingPong = e.usesPingPong || !1, this.speed = e.speed ?? .5, this.parentLayer = e.parentLayer || !1, this.animating = e.animating || !1, this.isMask = e.isMask || 0, this.texture = e.texture || null, this.mouseMomentum = e.mouseMomentum || 0; for (let s in e) this[s] || (this[s] = e[s]); this.breakpoints.length && this.setBreakpointValues() } unpackage() { for (let e in this) this[e] && this[e].type && ("Vec2" === this[e].type ? this[e] = new S(this[e]._x, this[e]._y) : "Vec3" === this[e].type && (this[e] = new M(this[e]._x, this[e]._y, this[e]._z))); return this } getParent() { return this.state().layers.filter(e => e.effects && e.effects.length).find(e => e.effects.includes(this.parentLayer)) } } class We extends Ue { constructor(e, t, i) { super(e, t), s(this, "layerType", "image"), s(this, "isElement", !0), this.initOptions = i; let r = this.default(e || {}); for (let s in r) this[s] = r[s]; this.breakpoints.length && this.setBreakpointValues(), Object.keys(e).length && (this.createLocalCanvas(), this.loadImage()) } default(e) { return { fitToCanvas: e.fitToCanvas || !1, src: e.src || "" } } unpackage() { return this.effects = be(this.effects), this } loadImage() { const e = new Image; e.crossOrigin = "Anonymous", e.addEventListener("load", () => { const t = this.state(); this.local.img = e, this.render = this.renderImage, this.render(), t.renderFrame && t.renderFrame(), this.local.loaded = !0 }, !1), e.src = this.src } renderImage() { var e, t; if (!(null == (e = this.local) ? void 0 : e.ctx)) return; let s = this.local.ctx; const i = this.state(); s.clearRect(0, 0, i.canvasWidth, i.canvasHeight); let { left: r, top: a, width: n, height: o } = this.box(), h = i.canvasWidth, l = i.canvasHeight; if (this.fitToCanvas) { let e = this.local.img.width / this.local.img.height; h / l < e ? (o = l, n = l * e) : (n = h, o = h / e); const t = (h - n) / 2, i = (l - o) / 2; s.drawImage(this.local.img, t, i, n, o) } else { const e = Le(this.anchorPoint), i = 2 * ((null == (t = this.local.stateEffectProps) ? void 0 : t.rotation) ?? this.rotation) * Math.PI; let h = e.x * n, l = e.y * o; s.save(); let d = n / 2, u = o / 2, c = r - h + d, p = a - l + u; s.translate(c, p), s.rotate(i), s.drawImage(this.local.img, -d, -u, n, o), s.restore() } } render() { } } class Ne extends ze { constructor(e, t, i) { var r; super(e, t, i), s(this, "layerType", "model"), s(this, "isModel", !0), s(this, "contextType", "webgl"), e.moduleRef && (null == (r = null == i ? void 0 : i.modules) ? void 0 : r[e.moduleRef]) && (this.moduleUrl = i.modules[e.moduleRef].url), this.trackMouse = void 0 !== e.trackMouse ? e.trackMouse : 0, this.mouseMomentum = void 0 !== e.mouseMomentum ? e.mouseMomentum : 0, this.trackAxes = e.trackAxes || "xy", this.lightTracking = void 0 !== e.lightTracking ? e.lightTracking : 0, this.rotationTracking = void 0 !== e.rotationTracking ? e.rotationTracking : 0, this.speed = void 0 !== e.speed ? e.speed : .5, this.pos = new M(e.pos._x, e.pos._y, e.pos._z), this.modelUrl = e.modelUrl, this.scale = e.scale, this.modelRotation = new M(e.modelRotation._x, e.modelRotation._y, e.modelRotation._z), this.lightIntensity = e.lightIntensity, this.lightColor = e.lightColor, this.ambientLightColor = e.ambientLightColor, this.fillLightColor = e.fillLightColor, this.ambientLightIntensity = e.ambientLightIntensity ?? 1.5, this.fillLightIntensity = e.fillLightIntensity ?? 1, this.lightPosition = new M(e.lightPosition._x, e.lightPosition._y, e.lightPosition._z), this.materialMetalness = e.materialMetalness, this.materialRoughness = e.materialRoughness, this.refractScale = e.refractScale, this.animationAxis = new M(e.animationAxis._x, e.animationAxis._y, e.animationAxis._z), this.renderNormals = e.renderNormals, this.animating = e.animating, this.opacity = e.opacity, this.colorMapUrl = e.colorMapUrl, this.colorMapScale = e.colorMapScale ?? 1, this.colorMapPosition = e.colorMapPosition ? new S(e.colorMapPosition.x ?? .5, e.colorMapPosition.y ?? .5) : new S(.5, .5), this.colorMapIntensity = e.colorMapIntensity ?? 1, this.quality = e.quality || "fast", this.environmentMapIntensity = e.environmentMapIntensity ?? 0, this.environmentMapUrl = e.environmentMapUrl || "", this.normalMapUrl = e.normalMapUrl || "", this.normalMapScale = e.normalMapScale ?? 1, this.normalMapPosition = e.normalMapPosition ? new S(e.normalMapPosition.x ?? .5, e.normalMapPosition.y ?? .5) : new S(.5, .5), this.normalMapIntensity = e.normalMapIntensity ?? 1, this.extrudeDepth = e.extrudeDepth ?? 10, this.bevelEnabled = e.bevelEnabled ?? !1, this.bevelThickness = e.bevelThickness ?? 1, this.bevelSize = e.bevelSize ?? 1, this.bevelSegments = e.bevelSegments ?? 2, this.glassIOR = e.glassIOR ?? 1.5, this.glassThickness = e.glassThickness ?? .5, this.glassRoughness = e.glassRoughness ?? 0, this.glassTint = e.glassTint || "#ffffff", this.glassDispersion = e.glassDispersion ?? 0 } unpackage() { return this.pos = new M(this.pos._x, this.pos._y, this.pos._z), this.modelRotation = new M(this.modelRotation._x, this.modelRotation._y, this.modelRotation._z), this.lightPosition = new M(this.lightPosition._x, this.lightPosition._y, this.lightPosition._z), this.animationAxis = new M(this.animationAxis._x, this.animationAxis._y, this.animationAxis._z), this } async loadRenderer() { const e = this.state(); if (!e.curtain || !e.curtain.renderer || !e.curtain.renderer.gl) return; let t = this.moduleUrl || "https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v1.5.3/extensions/model-renderer.js"; try { const s = await import(t); this.local.initialize = s.initialize, this.local.loadModel = s.loadModel, this.local.draw = s.draw, this.local.dispose = s.dispose, this.local.rendererLoaded = !0, requestAnimationFrame(() => { const t = e.curtain.renderer.gl; this.local.renderTarget && !this.local.renderTarget._frameBuffer && this.local.renderTarget._initRenderTarget(), this.local.initialize(t, this), this.local.initialized = !0, this.local.loadModel(this) }) } catch (s) { } } handleModelLoaded() { if (this.local.modelLoaded = !0, this.local.renderTarget) { let e = this.local.renderTarget.getTexture(), t = this.getPlane().textures.find(e => "uTexture" === e._samplerName); t.copy(e), t.needUpdate() } } renderModel() { var e, t; if (!this.local.rendererLoaded || !this.local.modelLoaded) return; const s = this.state(); if (!s || s.destroyed || !s.curtain || !s.curtain.renderer || !s.curtain.renderer.gl) return; const i = s.curtain.renderer.gl; if (0 === i.drawingBufferWidth || 0 === i.drawingBufferHeight) return; if (this.animating) { void 0 === this.local.time && (this.local.time = 0); let t = (null == (e = this.local.stateEffectProps) ? void 0 : e.speed) ?? this.speed ?? .5; const i = s.fps ? 60 / s.fps : 1; this.local.time += t * i * 60 } if (this.environmentMapIntensity > 0) { const e = this.getPlane(); if (e && !(null == (t = this.environmentMapUrl) ? void 0 : t.trim())) { const t = e.textures.find(e => "uBgTexture" === e._samplerName); t && t._sampler && t._canDraw && (this.local.envTexture = { gl: i, webglTexture: t._sampler.texture, width: t._size.width, height: t._size.height }) } } else this.local.envTexture = null; if (this.renderNormals) { const e = this.getPlane(); if (e) { const t = e.textures.find(e => "uBgTexture" === e._samplerName); t && t._sampler && t._sampler.texture && (this.local.backgroundTexture = { gl: i, webglTexture: t._sampler.texture, width: t._size.width, height: t._size.height }) } } const r = void 0 !== this.local.time ? this.local.time : performance.now(); if (this.local.renderTarget) if (this.local.renderTarget._frameBuffer) { const e = this.local.renderTarget._frameBuffer, t = this.local.renderTarget._size.width, s = this.local.renderTarget._size.height; i.bindFramebuffer(i.FRAMEBUFFER, e), i.viewport(0, 0, t, s); try { const e = i.getParameter(i.CURRENT_PROGRAM); this.local.draw(i, r, this), e && i.useProgram(e) } finally { i.bindFramebuffer(i.FRAMEBUFFER, null), i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight) } } else this.local.draw(i, r, this) } resize() { } cleanup() { this.local.dispose && this.local.dispose(this), this.local.initialize = null, this.local.loadModel = null, this.local.draw = null, this.local.dispose = null, this.local.rendererLoaded = !1, this.local.initialized = !1, this.local.modelLoaded = !1, this.local.renderTarget && (this.local.renderTarget.remove(), this.local.renderTarget = null) } isAnimating() { return this.visible && (this.animating || this.trackMouse > 0 || this.rotationTracking > 0) } getProp(e) { var t; return (null == (t = this.local.stateEffectProps) ? void 0 : t[e]) ?? this[e] } dispose() { this.cleanup(), super.dispose() } } class He extends Ue { constructor(e, t, i, r) { super(e, t), s(this, "layerType", "text"), this.initOptions = r; let a = this.default(e || {}); for (let s in a) this[s] = a[s]; this.breakpoints.length && this.setBreakpointValues(), this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), Object.keys(e).length && this.createLocalCanvas(), this.loadFont() } default(e) { return { fill: e.fill || ["#ffffff"], fontSize: e.fontSize ?? 24, fontSizeMode: e.fontSizeMode || "fixed", fontCSS: e.fontCSS || null, lineHeight: e.lineHeight ?? 25, letterSpacing: e.letterSpacing || 0, fontFamily: e.fontFamily || "arial", fontStyle: e.fontStyle || "normal", fontWeight: e.fontWeight || "normal", textAlign: e.textAlign || "left", textContent: e.textContent || "", gradientAngle: e.gradientAngle || e.gradAngle || 0, gradientType: e.gradientType || e.gradType || "linear", noTextAsHtml: e.noTextAsHtml || !1 } } unpackage() { return this.fill = be(this.fill), this.effects = be(this.effects), this } loadFont() { var e; const t = this.fontStyle.includes("italic") ? "italic" : "normal", s = e => "normal" === e || "400" === e || 400 === e ? "normal" : e.toString(), i = isNaN(parseInt(this.fontWeight)) ? "normal" : s(this.fontWeight); if (Array.from(document.fonts).some(e => e.family === this.fontFamily && e.style === t && s(e.weight) === i && "loaded" === e.status) || !(null == (e = this.fontCSS) ? void 0 : e.src)) return void this.handleFontLoaded(); let r = this.fontCSS.src.split(" ").join("%20"); const a = new FontFace(this.fontFamily, `url(${r})`, { style: t, weight: i }); document.fonts.add(a), a.load().then(() => { this.handleFontLoaded() }).catch(e => { this.handleFontLoaded() }) } handleFontLoaded() { this.local.loaded = !0, this.render(), this.render(); const e = this.state(); e.renderFrame && e.renderFrame(), Se(this, this.state().element) } getAbsoluteFontValues(e) { var t, s, i, r, a, n; const o = (null == (s = null == (t = this.local) ? void 0 : t.stateEffectProps) ? void 0 : s.fontSize) || this.fontSize, h = (null == (r = null == (i = this.local) ? void 0 : i.stateEffectProps) ? void 0 : r.lineHeight) || this.lineHeight, l = (null == (n = null == (a = this.local) ? void 0 : a.stateEffectProps) ? void 0 : n.letterSpacing) || this.letterSpacing, d = "fixed" === this.fontSizeMode ? o : o * e.canvasWidth; return { fontSize: d, lineHeight: "fixed" === this.fontSizeMode ? h : h * d, letterSpacing: "fixed" === this.fontSizeMode ? l : l * d } } render() { var e, t, s; if (!(null == (e = this.local) ? void 0 : e.ctx)) return; let i = this.local.ctx, { left: r, top: a, width: n } = this.box(); const o = Le(this.anchorPoint), h = (null == (s = null == (t = this.local) ? void 0 : t.stateEffectProps) ? void 0 : s.rotation) || this.rotation; let l = this.state(), d = this.height, u = r - o.x * n, c = a - o.y * d, p = 0, { fontSize: m, lineHeight: g, letterSpacing: f } = this.getAbsoluteFontValues(l), _ = this.fontStyle.includes("italic") ? "italic" : "normal", x = /^\d+$/.test(this.fontStyle) ? this.fontStyle : "400"; i.clearRect(0, 0, l.canvasWidth, l.canvasHeight), i.font = `${_} ${x} ${m}px/${g}px ${this.fontFamily}, -apple-system, BlinkMacSystemFont, Helvetica, Arial`, this.isSafari || (i.textAlign = this.textAlign, i.letterSpacing = f + "px"); const v = i.measureText("m").width; n = Math.max(n, v), i.save(); let y = u + n / 2, b = c + d / 2; i.translate(y, b), i.rotate(360 * h * Math.PI / 180), i.translate(-y, -b), "center" === this.textAlign && (u += n / 2), "right" === this.textAlign && (u += n), i.fillStyle = ve(i, this.box(), this.fill, this.gradientAngle, this.gradientType); const P = (e, t) => { let s = c + g * t + g / 2 + m / 3; this.isSafari ? ((e, t, s, i, r, a, n) => { let o, h = t.split("").reduce((s, i, a) => s + e.measureText(i).width + (a < t.length - 1 ? r : 0), 0); if (o = "center" === a ? s + (n - h) / 2 - n / 2 : s, "right" === a) for (let l = t.length - 1; l >= 0; l--) { const s = t[l]; o -= e.measureText(s).width, e.fillText(s, o, i), l > 0 && (o -= r) } else for (let l = 0; l < t.length; l++)e.fillText(t[l], o, i), o += e.measureText(t[l]).width + r })(i, e, u, s, f, this.textAlign, n) : i.fillText(e, u, s) }, w = this.textContent ? this.textContent.split("\n") : [""]; let T = w.length; const R = (e, t, s) => t.split("").reduce((i, r, a) => (i += e.measureText(r).width, a < t.length - 1 && (i += s), i), 0); for (let S = 0; S < T; S++) { let e = "", t = w[S].split(/(\s|\n)/); for (let s = 0; s < t.length; s++) { const r = t[s], a = e + r; if ((this.isSafari && f ? R(i, a, f) : i.measureText(a).width) > n || "\n" === r) { if ("" !== e) w[S] = e.trim(), s !== t.length - 1 ? (w.splice(S + 1, 0, t.slice(s).join("")), T++) : "\n" !== r && w.push(r); else { let e = r, a = S; for (; e.length > 0;) { let t = ""; for (let s = 0; s < e.length && (i.measureText(t + e[s]).width <= n || 0 == s); s++)t += e[s]; e = e.slice(t.length), w[a] = t.trim(), e.length > 0 && (w.splice(a + 1, 0, e), a++, T++) } t.slice(s + 1).length > 0 && (w[a] += t.slice(s + 1).join("")) } break } e = a, s === t.length - 1 && (w[S] = e.trim()) } } w.forEach((e, t) => { P(e, p), t < w.length - 1 && p++ }), i.translate(-(u + n / 2), -(c + d / 2)), i.restore(), this.height = g * p + g } } function je() { let e = performance.now(); document[ae] ? (cancelAnimationFrame(oe), Qe.forEach(t => { t.pauseTime = e })) : (Ee(), Qe.forEach(t => { t.pauseTime = t.pauseTime - e, t.curtain.planes.forEach(e => { e.videos.forEach(e => { e.play() }) }) })) } function Ge() { de = window.innerHeight || document.documentElement.clientHeight, ue = window.innerWidth || document.documentElement.clientWidth, Qe.filter(e => e.initialized).forEach(e => { e.refresh() }), Ye() } function Xe(e, t, s = 50) { const i = t || e.getBoundingClientRect(), r = i.top >= -s && i.top <= de + s || i.bottom >= -s && i.bottom <= de + s || i.top <= 0 && i.bottom >= de, a = i.left >= -s && i.left <= ue + s || i.right >= -s && i.right <= ue + s || i.left <= 0 && i.right >= ue; return r && a } function Ye() { Qe.filter(e => e.getDynamicLayers().length).forEach(e => { let t = e.element.getBoundingClientRect(); if (e.scrollY = ce, e.lastBbox) { 0 === Math.abs(t.top - e.lastBbox.top) && me > 0 ? (e.fixedCounter = (e.fixedCounter || 0) + 1, e.fixedCounter > 3 && (e.isFixed = !0)) : e.fixedCounter = 0 } e.lastBbox = e.bbox, e.bbox = t }) } function qe(e) { const t = Qe.filter(e => e.getDynamicLayers().length), s = Qe.filter(e => e.rendering); t.length && !s.length && Ee(); const i = performance.now(); (!ge || i - ge > 64) && Ye(), t.forEach(e => { if (Xe(e.element, e.bbox, 100)) { if (!e.isInView) { e.isInView = !0, e.pauseTime = e.pauseTime - i; const t = e.element.offsetWidth > 0 && e.element.offsetHeight > 0; t && e.curtain ? e.resize() : t || requestAnimationFrame(() => { e.element.offsetWidth > 0 && e.element.offsetHeight > 0 && e.curtain && e.resize() }), !e.lazyLoad || e.initialized || e.initializing || e.initializePlanes() } } else e.isInView && (e.isInView = !1, e.pauseTime = i) }) } function $e(e) { Qe.filter(e => e.isInView).forEach(e => { e.mouse.page.x = 99999999999, e.mouse.page.y = 99999999999, e.mouse.enterTime = null }) } function Ze(e) { let t = performance.now(); Qe.filter(e => e.isInView && e.initialized).forEach(s => { let i, r, a = s.bbox; Math.abs(me) > 1 && t - s.lastBboxTime > 64 && (a = s.element.getBoundingClientRect(), s.lastBbox = s.bbox, s.bbox = a, s.lastBboxTime = t), e.targetTouches ? (i = e.targetTouches[0].pageX, r = e.targetTouches[0].pageY) : (i = e.pageX, r = e.pageY), s.isFixed && (s.scrollY = 0, r = e.targetTouches ? e.targetTouches[0].clientY : e.clientY); const n = i - a.left, o = r - (a.top + (s.isFixed ? 0 : ce)); s.mouse.page.x = i, s.mouse.page.y = r, s.mouse.movePos.x = .5 * n, s.mouse.movePos.y = .5 * o, s.mouse.movedInView = !0 }) } let Qe = []; class Je { constructor(e) { s(this, "local", { preloadedTextures: {} }), s(this, "scrollY", 0), s(this, "paused", !1), s(this, "destroyed", !1), s(this, "lastBboxTime", 0), this.id = e.id, this.breakpoints = [{ name: "Desktop", max: 1 / 0, min: 992 }, { name: "Tablet", max: 991, min: 576 }, { name: "Mobile", max: 575, min: 0 }], this.projectId = e.projectId, this.canvasWidth = e.width || e.element.offsetWidth || ue, this.canvasHeight = e.height || e.element.offsetHeight || de, this.curtain = void 0, this.curtainRafId = void 0, this.dpi = +e.dpi || Math.min(1.5, window.devicePixelRatio), this.element = e.element, this.fps = e.fps || 60, this.name = e.name, this.frameDuration = Math.floor(1e3 / (e.fps || 60)), this.layers = e.layers, this.lazyLoad = e.lazyLoad, this.initialized = !1, this.lasTick = null, this.lastTime = 0, this.rendering = !1, this.bbox = {}, this.isFixed = e.fixed || "fixed" === window.getComputedStyle(this.element).position, this.interactivity = { mouse: { disableMobile: !1, disabled: !1 } }, this.mouse = { downPos: { x: .5, y: .5 }, movePos: { x: .5, y: .5 }, lastPos: { x: .5, y: .5 }, delta: { x: 0, y: 0 }, page: { x: 99999999999, y: 99999999999 }, dragging: !1, movedInView: !1, enterTime: null, ticks: 0, pos: { x: 0, y: 0 } }, this.renderingScale = e.renderingScale || 1, this.scale = e.scale || 1, this.split = !1, this.versionId = "", e.width && e.height && (this.element.style.width = e.width + "px", this.element.style.height = e.height + "px"), this.bbox = this.element.getBoundingClientRect(), this.lastBbox = this.bbox, this.currentBreakpoint = this.breakpoints.find(e => ue >= e.min && ue <= e.max), this.createCurtains(), this.setCanvasScale(), this.curtain && (this.textureLoader = new F(this.curtain)) } preloadTextures() { this.layers.forEach(e => { var t, s, i, r, a, n, o, h, l; if (e.isElement) e.local.canvas && this.textureLoader.loadCanvas(e.local.canvas, { sampler: "uTexture", premultiplyAlpha: !0 }, t => { t.userData.hasStateEffects = e.states.appear.length > 0 || e.states.scroll.length > 0 || e.states.hover.length > 0, e.preloadedCanvasTexture = t }, e => { }); else if ((null == (t = null == e ? void 0 : e.texture) ? void 0 : t.src) || (null == (i = null == (s = null == e ? void 0 : e.data) ? void 0 : s.texture) ? void 0 : i.src)) { const t = (null == (r = null == e ? void 0 : e.texture) ? void 0 : r.src) || (null == (n = null == (a = null == e ? void 0 : e.data) ? void 0 : a.texture) ? void 0 : n.src), s = (null == (o = null == e ? void 0 : e.texture) ? void 0 : o.sampler) || (null == (l = null == (h = null == e ? void 0 : e.data) ? void 0 : h.texture) ? void 0 : l.sampler) || "uTexture"; this.local.preloadedTextures[t] ? this.local.preloadedTextures[t].count++ : (this.local.preloadedTextures[t] = { count: 1, texture: null }, this.textureLoader.loadImage(t, { sampler: s, premultipliedAlpha: !1 }, e => { this.local.preloadedTextures[t].texture = e })) } }) } setCanvasScale() { this.canvasWidth = this.element.offsetWidth, this.canvasHeight = this.element.offsetHeight } destroy() { var e, t; this.destroyed = !0, this.rendering = !1, this.isInView = !1; const s = Qe.findIndex(e => e.id === this.id); -1 !== s && Qe.splice(s, 1), this.layers.filter(e => e.dispose).forEach(e => e.dispose()), this.layers = [], (null == (e = this.curtain) ? void 0 : e.gl) && (this.curtain.dispose(), this.curtain = null), this.element && (this.element.removeAttribute("data-us-initialized"), this.element.removeAttribute("data-scene-id"), null == (t = this.element.querySelector("canvas")) || t.remove(), this.element.querySelectorAll("[data-us-text]").forEach(e => { e.remove() })), Ee(), Qe.length || st() } resize() { this.lastBbox = this.bbox, this.bbox = this.element.getBoundingClientRect(), this.setCanvasScale(), this.layers.filter(e => e.isElement).forEach(e => { e.resize() }), this.currentBreakpoint = this.breakpoints.find(e => ue >= e.min && ue <= e.max), this.curtain && (this.curtain.resize(), this.curtain.canvas.style.width = this.canvasWidth + "px", this.curtain.canvas.style.height = this.canvasHeight + "px", this.curtain.planes.forEach(e => { e.uniforms.resolution && (e.uniforms.resolution.value.x = this.curtain.canvas.width, e.uniforms.resolution.value.y = this.curtain.canvas.height) })) } refresh() { this.initialized = !1, this.layers.forEach(e => { var t, s; null == (t = e.states) || t.scroll.forEach(e => e.resetState()), null == (s = e.states) || s.appear.forEach(t => { e[t.prop] = t.endValue ?? e.local.stateEffectProps[t.prop] ?? e[t.prop] }), e.breakpoints.length && (e.setBreakpointValues(), e.local.bpProps && Object.keys(e.local.bpProps).forEach(t => { e.getPlanes().forEach(s => { s.uniforms[t] && Ae(e.local.bpProps[t], s.uniforms[t], t) }) })), e.preloadedCanvasTexture && (e.preloadedCanvasTexture.shouldUpdate = !0) }), requestAnimationFrame(() => { this.curtain && (this.curtain.planes.forEach(e => { e._canDraw = !0 }), this.scrollY = ce, this.resize(), this.handlePlaneCreation()) }) } getDynamicLayers() { return this.layers.filter(e => Re(e)) } createCurtains() { this.curtain = new p({ container: this.element, premultipliedAlpha: !0, antialias: !1, autoRender: !1, autoResize: !1, watchScroll: !1, renderingScale: Math.min(Math.max(.25, this.renderingScale), 1), production: !1, pixelRatio: this.dpi }), this.curtain.gl && (this.curtain.onError(e => { }), this.curtain.onContextLost(() => { this.curtain.restoreContext() }), this.curtain.onContextRestored(() => { this.initialized && (this.layers.forEach(e => { e.preloadedCanvasTexture && (e.preloadedCanvasTexture.shouldUpdate = !0) }), requestAnimationFrame(() => { this.curtain && (this.curtain.planes.forEach(e => { e._canDraw = !0 }), this.renderFrame()) })) }), this.scrollY = ce) } renderFrame() { var e; this.destroyed || (e = this.curtain) && e.renderer && e.renderer.nextRender && "function" == typeof e.renderer.nextRender.execute && (this.layers.forEach(e => { e.local.currentFrameMouseValues = null }), this.handleStateEffects(), this.curtain.render()) } renderNFrames(e, t) { let s = 0; const i = () => { this.renderFrame(), s < e ? (s++, requestAnimationFrame(i)) : t && t() }; this.rendering || i() } setInteractiveParams(e, t) { let s = { mouse: { disableMobile: !1, disabled: !1 } }; t && t.mouse && ("disableMobile" in t.mouse && (s.mouse.disableMobile = t.mouse.disableMobile), "disabled" in t.mouse && (s.mouse.disabled = t.mouse.disabled)), e && e.interactivity && e.interactivity.mouse && ("disableMobile" in e.interactivity.mouse && (s.mouse.disableMobile = e.interactivity.mouse.disableMobile), "disabled" in e.interactivity.mouse && (s.mouse.disabled = e.interactivity.mouse.disabled)), this.interactivity = s } getSplitOrderedItems() { let e = this.getOrderedItems(), t = 0, s = e[t]; if (s) { let i = s.parentLayer ? s.getParent() : null, r = i && Re(i), a = i && i.effects && i.effects.length && i.getChildEffectItems().filter(e => Re(e)).length; for (; s && !Re(s) && !r && !a;)t++, s = e[t], s && (i = s.parentLayer ? s.getParent() : null, r = i && Re(i), a = i && i.effects && i.effects.length && i.getChildEffectItems().filter(e => Re(e)).length); return { static: this.getOrderedItems().splice(0, t), dynamic: this.getOrderedItems().splice(t) } } return { static: [], dynamic: [] } } initializePlanes(e) { this.initializing = !0, this.handleItemPlanes(() => { this.handlePlaneCreation(), e && e(this) }) } getPassPlane(e, t) { var s; return null == (s = this.curtain) ? void 0 : s.planes.find(s => s.userData.id === e.local.id && s.userData.passIndex === t) } getRenderTargets() { var e; return null == (e = this.curtain) ? void 0 : e.renderTargets.filter(e => e.userData.id) } getPlanes() { var e; return null == (e = this.curtain) ? void 0 : e.planes.filter(e => "PingPongPlane" !== e.type) } getPlaneParams(e, t) { var s, i, r, a, n; let o = (null == (s = e.data) ? void 0 : s.heightSegments) || (null == (i = e.data) ? void 0 : i.widthSegments) ? 500 : 1; const h = { resolution: { name: "uResolution", type: "2f", value: new S(this.canvasWidth, this.canvasHeight) }, mousePos: { name: "uMousePos", type: "2f", value: new S(.5) }, time: { name: "uTime", type: "1f", value: 0 }, dpi: { name: "uDpi", type: "1f", value: this.dpi * +this.renderingScale } }; e.isElement && (h.sampleBg = { name: "uSampleBg", type: "1i", value: 1 }), e.isModel && (h.opacity = { name: "uOpacity", type: "1f", value: 1 }), e.usesPingPong && (h.previousMousePos = { name: "uPreviousMousePos", type: "2f", value: new S(.5) }); let l = e.compiledFragmentShaders[t] || e.compiledFragmentShaders[0], d = e.compiledVertexShaders[t] || e.compiledVertexShaders[0]; if (e.states && [...e.states.appear, ...e.states.scroll, ...e.states.hover].forEach(t => { h[t.prop] || t.uniformData && (h[t.prop] = t.uniformData, h[t.prop].value = e[t.prop]) }), null == (r = e.data) ? void 0 : r.uniforms) for (let u in e.data.uniforms) { let t = e.data.uniforms[u]; h[u] = e.data.uniforms[u], "Vec3" === (null == (a = t.value) ? void 0 : a.type) ? h[u].value = new M(t.value._x, t.value._y, t.value._z) : "Vec2" === (null == (n = t.value) ? void 0 : n.type) ? h[u].value = new S(t.value._x, t.value._y) : "object" == typeof t.value && (h[u].value = be(t.value)) } return { fragmentShader: l, vertexShader: d, widthSegments: o, heightSegments: o, texturesOptions: { floatingPoint: "half-float", premultiplyAlpha: !0 }, uniforms: h } } createPlane(e, t, s) { var i; let r, a; r = e.isElement || e.isModel ? this.getPlaneParams(e) : this.getPlaneParams(e, s ? s.index : null), r.watchScroll = !1; try { if (!this.curtain.container) throw new Error("Can't find scene container"); let n = (null == s ? void 0 : s.downSample) || 0 === (null == s ? void 0 : s.index) && (null == (i = e.data) ? void 0 : i.downSample), o = this.renderingScale; if (n && (o = "number" == typeof n ? n : .5, o *= this.renderingScale), e.userDownsample && "number" == typeof e.userDownsample && (o *= e.userDownsample), a = new se(this.curtain, this.curtain.container, r), !a || !a.userData || !a.textures) throw new Error("Plane not properly initialized"); return a.textures.length = 0, a.userData.id = e.local.id, a.userData.layerType = e.layerType, a.userData.type = e.type, a.userData.downSample = o, a.setRenderOrder(t), a } catch (n) { return null } } createPingPongPlane(e, t, s) { var i; let r = this.getPlaneParams(e, 1 + ((null == s ? void 0 : s.length) || 0)), a = null == (i = this.curtain) ? void 0 : i.planes.find(t => "PingPongPlane" === t.type && t.userData.id === e.local.id); if (a) a.setRenderOrder(t); else { if (a = new re(this.curtain, this.curtain.container, r), !a) return; a.userData.id = e.local.id, a.userData.pingpong = !0, a.setRenderOrder(t), a.onReady(() => { this.setInitialEffectPlaneUniforms(a, e, null == e ? void 0 : e.getParent(), s), a.userData.isReady = !0 }).onRender(() => { this.setEffectPlaneUniforms(a, e) }) } if (a) return a } createEffectPlane(e, t, s) { const i = this.createPlane(e, t, s); if (!i) return; const r = e.getParent(); if (!i || !i.userData || !i.textures) throw new Error("Plane not properly initialized", i); s && (i.userData.passIndex = s.index, i.userData.length = e.data.passes.length, Object.entries(s).forEach(([e, t]) => { i.uniforms[e] && (i.uniforms[e].value = t) })), this.setInitialEffectPlaneUniforms(i, e, r, s), i.onReady(() => { i.userData.isReady = !0 }).onRender(() => this.setEffectPlaneUniforms(i, e)) } createElementPlane(e, t) { const s = this.createPlane(e, t); s && s.onReady(() => { this.setInitialElementPlaneUniforms(s, e), s.userData.isReady = !0 }).onRender(() => this.setElementPlaneUniforms(s, e)) } handleMediaTextures(e, t, s) { var i; if ([t.texture, null == (i = t.data) ? void 0 : i.texture].filter(e => null == e ? void 0 : e.src).forEach(i => { var r; if (null == (r = t.compiledFragmentShaders[s.passIndex ?? 0]) ? void 0 : r.includes(i.sampler)) { const t = this.local.preloadedTextures[i.src]; (null == t ? void 0 : t.texture) ? (t.count > 1 ? (Fe(e, i.sampler, t.texture), t.count--) : e.addTexture(t.texture), e.userData.textureLoaded = !0) : this.textureLoader.loadImage(i.src, { premultipliedAlpha: !1, sampler: i.sampler }, t => { e.addTexture(t), e.userData.textureLoaded = !0 }) } }), "video" === t.type) { const s = t.src.includes(", ") ? function (e) { const t = e.split(",").map(e => e.trim()), s = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i = /iPad|iPhone|iPod/.test(navigator.userAgent); if (s || i) { const e = t.find(e => e.endsWith(".mov") || e.endsWith(".mp4")); if (e) return e } return t.find(e => e.endsWith(".webm")) || t[0] }(t.src) : t.src; e.loadVideo(s, { premultipliedAlpha: !0, sampler: "uVideoTexture" }, s => { e.videos.at(-1).loop = !t.hasOwnProperty("loop") || t.loop, e.videos.at(-1).playbackRate = t.playbackRate || 1, e.videos.at(-1).play(), e.userData.textureLoaded = !0 }) } } handleEffectPlane(e, t, s) { var i; const r = "passIndex" in s ? this.getPassPlane(e, s.passIndex) : e.getPlane(); if (!r) return !1; let a = this.getRenderTargets()[t - 1], n = null == (i = this.curtain) ? void 0 : i.planes.find(t => "PingPongPlane" === t.type && t.userData.id === e.local.id), o = e.compiledFragmentShaders[s.passIndex ?? 0]; if (n && (null == o ? void 0 : o.includes("uPingPongTexture")) && Fe(r, "uPingPongTexture", n.getTexture()), a ? Fe(r, "uTexture", a.getTexture()) : Fe(r, "uTexture"), null == o ? void 0 : o.includes("uBgTexture")) { let e = this.getRenderTargets()[t - (1 + s.passIndex)]; e && Fe(r, "uBgTexture", e.getTexture()) } this.handleMediaTextures(r, e, s) } handleModelPlane(e, t) { var s; const i = e.getPlane(); let r = this.getRenderTargets()[t - 1]; const a = this.layers.filter(e => !e.parentLayer); let n = a[a.indexOf(e) - 1]; i.textures.forEach(e => { }), i.textures = [], (null == (s = e.local.renderTarget) ? void 0 : s.getTexture) && e.local.modelLoaded ? i.addTexture(e.local.renderTarget.getTexture()) : i.createTexture({ sampler: "uTexture", premultipliedAlpha: !0, fromTexture: r.getTexture() }), r && e.renderNormals && i.createTexture({ sampler: "uRefractTexture", premultipliedAlpha: !0, fromTexture: r.getTexture() }), n.local.lastTarget && i.createTexture({ sampler: "uBgTexture", premultipliedAlpha: !0, fromTexture: n.local.lastTarget.getTexture() }) } handleElementPlane(e, t) { const s = e.getPlane(); if (!s) return !1; const i = e.getChildEffectItems(), r = this.layers.filter(e => !e.parentLayer); let a, n = this.getRenderTargets()[t - 1], o = e.maskDepthLayer || 1, h = r[r.indexOf(e) - (1 + o)]; if (e.mask && h && (a = h.local.lastTarget), i.length || (s.textures.length = 0), n && i.length ? Fe(s, "uTexture", n.getTexture()) : s && s.addTexture(e.preloadedCanvasTexture), n) { if (i.length) { let e = i.reduce((e, t) => e + t.getPlanes().length, 0); n = this.getRenderTargets()[t - (1 + e)] } n && (Fe(s, "uBgTexture", n.getTexture()), a && e.mask && Fe(s, "uPreviousLayerTexture", a.getTexture())) } } handleChildEffectPlane(e, t, s) { var i; const r = "passIndex" in s ? this.getPassPlane(e, s.passIndex) : e.getPlane(); if (!r) return; const a = e.getParent(); let n = this.getRenderTargets()[t - 1], o = null == (i = this.curtain) ? void 0 : i.planes.find(t => "PingPongPlane" === t.type && t.userData.id === e.local.id), h = e.compiledFragmentShaders[s.passIndex ?? 0], l = a.effects.filter(e => { if (this.layers.find(t => t.parentLayer === e)) return this.layers.find(t => t.parentLayer === e) }), d = l.indexOf(e.parentLayer), u = l[l.length - 1] === l[d], c = s.passIndex === s.length; if (n && (d || s.passIndex > 0) ? (e.isMask && (!s.length || u && c) && r.addTexture(a.preloadedCanvasTexture), Fe(r, "uTexture", n.getTexture())) : e.isMask ? (u && c && r.addTexture(a.preloadedCanvasTexture), n ? Fe(r, "uTexture", n.getTexture()) : Fe(r, "uTexture")) : (null == h ? void 0 : h.includes("uTexture")) && (r.addTexture(a.preloadedCanvasTexture), a.preloadedCanvasTexture.userData.used = !0), o && (null == h ? void 0 : h.includes("uPingPongTexture")) && Fe(r, "uPingPongTexture", o.getTexture()), null == h ? void 0 : h.includes("uBgTexture")) if (d && s.length > 1) { let e = this.getRenderTargets()[t - (1 + s.length)]; e && Fe(r, "uBgTexture", e.getTexture()) } else a.preloadedCanvasTexture.userData.used ? r.loadCanvas(a.local.canvas, { sampler: "uBgTexture", premultiplyAlpha: !0 }, e => { e.shouldUpdate = a.preloadedCanvasTexture.shouldUpdate }) : (a.preloadedCanvasTexture._samplerName = "uBgTexture", r.addTexture(a.preloadedCanvasTexture)); "custom" === e.type && Fe(r, "uCustomTexture", this.getRenderTargets()[t]), this.handleMediaTextures(r, e, s) } createPlanes() { this.getOrderedItems().forEach((e, t) => { e.getPlanes().length ? e.getPlanes().forEach(e => e.setRenderOrder(t)) : e.isElement ? this.createElementPlane(e, t) : e.isModel ? this.createModelPlane(e, t) : this.createEffectPlanes(e, t) }) } createModelPlane(e, t) { const s = this.createPlane(e, t); s && s.onReady(() => { s.userData.isReady = !0, s.userData.createdAt = performance.now(); let t = e.userDownsample || 1, i = this.curtain.canvas.width * t, r = this.curtain.canvas.height * t; e.local.renderTarget || (e.local.renderTarget = new ie(this.curtain, { depth: !0, maxWidth: i, maxHeight: r, texturesOptions: { sampler: "uTexture", premultiplyAlpha: !0 } }), e.local.rendererLoaded || e.loadRenderer()) }).onRender(() => { this.setModelPlaneUniforms(s, e), this.curtain.gl && e.renderModel() }) } createEffectPlanes(e, t) { const s = e.data; s.passes && s.passes.length ? (this.createEffectPlane(e, t, { index: 0, downSample: s.downSample, length: s.passes.length + 1 }), s.passes.forEach((i, r) => { this.createEffectPlane(e, t, { index: r + 1, length: s.passes.length + 1, downSample: i.downSample, [i.prop]: i.value }) }), e.usesPingPong && this.createPingPongPlane(e, t, s.passes)) : (this.createEffectPlane(e, t), e.usesPingPong && this.createPingPongPlane(e, t)) } createTextures() { const e = this.getPlanes().sort((e, t) => e.renderOrder - t.renderOrder), t = e.length; for (let s = 0; s < t; s++) { const i = e[s]; let r = this.layers.find(e => e.local.id === i.userData.id); s < t - 1 && this.assignRenderTargetToPlane(e, s, r, i), this.handleTextures(r, s, i.userData), r.local.lastTarget = i.target } } assignRenderTargetToPlane(e, t, s, i) { let r = this.getTextureParams(e, t, s), a = this.getRenderTargets()[t] || new ie(this.curtain, r); a.userData.id = i.userData.id, i.setRenderTarget(a) } handleTextures(e, t, s) { e.isElement ? this.handleElementPlane(e, t) : e.isModel ? this.handleModelPlane(e, t) : e.parentLayer ? this.handleChildEffectPlane(e, t, s) : this.handleEffectPlane(e, t, s) } handleItemPlanes(e) { this.createPlanes(), this.createTextures(), this.checkIfReady(e) } checkIfReady(e) { const t = () => { var s; let i = !1; const r = null == (s = this.curtain) ? void 0 : s.planes; if (r) { for (let e = 0; e < r.length; e++)if (!r[e].userData.isReady) { i = !0; break } i ? (this.renderFrame(), requestAnimationFrame(t)) : e() } }; t() } setModelPlaneUniforms(e, t) { e.uniforms.resolution.value.x = this.curtain.canvas.width, e.uniforms.resolution.value.y = this.curtain.canvas.height; const s = this.calculateItemMouseValues(t); s && !t.local.mouse && (t.local.mouse = { x: .5, y: .5 }), s && (t.local.mouse.x = s.x, t.local.mouse.y = s.y), e.uniforms.opacity && (e.uniforms.opacity.value = t.local.modelLoaded ? t.opacity : 0) } setInitialEffectPlaneUniforms(e, t, s, i) { var r; if (!e.userData.initialUniformsSet || !e.userData.isReady) { for (let s in e.uniforms) (null == (r = t.states) ? void 0 : r.scroll.some(e => e.prop === s)) || (t.local.bpProps && s in t.local.bpProps ? Ae(t.local.bpProps[s], e.uniforms[s], s) : s in t && Ae(t[s], e.uniforms[s], s)); s && i && i.index < i.length - 1 && e.uniforms.isMask && (e.uniforms.isMask.value = 0), s && t.isMask && !t.mouseMomentum && (t.mouseMomentum = s.mouseMomentum), e.uniforms.resolution.value.x = this.curtain.canvas.width, e.uniforms.resolution.value.y = this.curtain.canvas.height, e.userData.initialUniformsSet = !0 } } handleStateEffects() { this.layers.forEach(e => { e.updateStateEffects() }) } setInitialElementPlaneUniforms(e, t) { var s; e.uniforms.resolution.value.x = this.curtain.canvas.width, e.uniforms.resolution.value.y = this.curtain.canvas.height; for (let i in e.uniforms) t.local.bpProps && i in t.local.bpProps ? e.uniforms[i].value = t.local.bpProps[i] : i in t && (e.uniforms[i].value = (null == (s = t.local.stateEffectProps) ? void 0 : s[i]) ?? t[i]); e.uniforms.sampleBg && (e.renderOrder - t.effects.length === 0 ? e.uniforms.sampleBg.value = 0 : e.uniforms.sampleBg.value = 1) } setElementPlaneUniforms(e, t) { if (e.uniforms.mousePos) { t.local.currentFrameMouseValues || (t.local.currentFrameMouseValues = this.calculateItemMouseValues(t)); const s = t.local.currentFrameMouseValues; if (!s) return; !this.mouse.movedInView || e.uniforms.mousePos.value.x === s.x && e.uniforms.mousePos.value.y === s.y || (e.uniforms.mousePos.value.x = s.x, e.uniforms.mousePos.value.y = s.y) } } calculateItemMouseValues(e) { if (!this.mouse.movedInView) return null; const t = this.bbox.width / 2, s = this.bbox.height / 2, i = this.getMousePosWithMomentum(e, t, s); return this.local.mouseValuePool || (this.local.mouseValuePool = new S(.5)), this.local.mouseValuePool.x = i.x, this.local.mouseValuePool.y = i.y, this.local.mouseValuePool } getMousePosWithMomentum(e, t, s) { let i = this.mouse.pos.x, r = this.mouse.pos.y, a = e.trackAxes || "xy", n = "x" === a || "xy" === a, o = "y" === a || "xy" === a; const h = e.mouseMomentum || 0; let l = i / t, d = 1 - r / s; if (!h) return { x: n ? l : .5, y: o ? d : .5 }; if (!e.local.lastMousePos) return e.local.lastMousePos = { x: n ? l : .5, y: o ? d : .5 }, e.local.lastMousePos; const u = e.local.lastMousePos.x * t, c = (1 - e.local.lastMousePos.y) * s, p = Math.abs(i - u), m = Math.abs(r - c); return p < fe && m < fe || (n ? (i = Pe(i, u, 2 * h), e.local.lastMousePos.x = i / t) : e.local.lastMousePos.x = .5, o ? (r = Pe(r, c, 2 * h), e.local.lastMousePos.y = 1 - r / s) : e.local.lastMousePos.y = .5), e.local.lastMousePos } setEffectPlaneUniforms(e, t) { var s, i, r, a; let n = (null == (s = t.local.stateEffectProps) ? void 0 : s.speed) ?? t.speed ?? 1; if (t.animating && e.uniforms.time && (e.uniforms.time.value += 60 * n / this.fps), (null == (i = t.local.stateEffectProps) ? void 0 : i.playbackRate) && e.videos.at(-1) && (e.videos.at(-1).playbackRate = t.local.stateEffectProps.playbackRate), we() && (null == (a = null == (r = this.interactivity) ? void 0 : r.mouse) ? void 0 : a.disableMobile)) return !1; if (!this.mouse.movedInView) return; t.local.currentFrameMouseValues || (t.local.currentFrameMouseValues = this.calculateItemMouseValues(t)); const o = t.local.currentFrameMouseValues; o && (e.uniforms.previousMousePos && (this.mouse.ticks > 16 ? (e.uniforms.previousMousePos.value.x = e.uniforms.mousePos.value.x, e.uniforms.previousMousePos.value.y = e.uniforms.mousePos.value.y) : (e.uniforms.previousMousePos.value.x = o.x, e.uniforms.previousMousePos.value.y = o.y)), e.uniforms.mousePos && !o.equals(e.uniforms.mousePos.value) && (e.uniforms.mousePos.value.x = o.x, e.uniforms.mousePos.value.y = o.y), this.mouse.ticks++) } getOrderedItems() { let e = []; return this.layers.filter(e => !e.parentLayer).forEach(t => { t.effects && t.effects.length && e.push(...t.getChildEffectItems()), e.push(t) }), e } getTextureParams(e, t, s) { var i; const r = e[t]; let a = 1; r.userData.downSample && (a = "number" == typeof r.userData.downSample ? r.userData.downSample : .5); return { maxWidth: this.curtain.canvas.width * a, maxHeight: this.curtain.canvas.height * a, depth: null == (i = null == s ? void 0 : s.data) ? void 0 : i.depth } } handlePlaneCreation() { this.initialized = !0, this.initializing = !1, this.rendering || this.renderNFrames(2), this.waitForAssetsAndDisablePlanes(), Ee() } waitForAssetsAndDisablePlanes() { this.layers.some(e => e.isModel && !e.local.modelLoaded || "image" === e.layerType || "text" === e.layerType && !e.local.loaded || Object.values(this.local.preloadedTextures).some(e => e && null === e.texture)) ? setTimeout(() => this.waitForAssetsAndDisablePlanes(), 64) : (this.layers.filter(e => e.preloadedCanvasTexture).forEach(e => { e.preloadedCanvasTexture.shouldUpdate = e.preloadedCanvasTexture.userData.hasStateEffects || !1 }), setTimeout(() => this.disablePlanes(), 16)) } disablePlanes() { const e = this.getSplitOrderedItems(); e.dynamic.length || e.static.pop(); for (const t of e.static) t.getPlanes().forEach(e => { e._canDraw = !1 }) } } function Ke(e, t, s) { e.addEventListener(t, s, { passive: !0 }) } function et(e, t, s) { e.removeEventListener(t, s) } function tt() { Ke(window, "scroll", qe), we() ? Ke(window, "touchmove", Ze) : Ke(window, "mousemove", Ze), Ke(window, "routeChange", Me), Ke(document, "mouseleave", $e), he = function (e, t) { let s; return function (...i) { clearTimeout(s), s = setTimeout(() => { e.apply(this, i) }, t) } }(Ge, 16), we() ? Ke(window, "orientationchange", he) : Ke(window, "resize", he), Ke(document, ne, je), le = !0 } function st() { et(window, "mousemove", Ze), et(window, "touchmove", Ze), et(window, "scroll", qe), et(window, "routeChange", Me), et(document, "mouseleave", $e), he && (et(window, "resize", he), et(window, "orientationchange", he)), et(document, ne, je), le = !1 } function it(e) { let t = e.projectId ? e.projectId.split("?")[0] : null, s = e.projectId ? e.projectId.split("?")[1] : null; return new Promise((i, r) => { (function (e, t, s, i, r) { let a; if (s) { a = s; const e = document.getElementById(s); if (e) try { let t = JSON.parse(e.innerText); return (null == t ? void 0 : t.options) && ((null == t ? void 0 : t.layers) || (null == t ? void 0 : t.history)) ? Promise.resolve(t) : (i(new Error(`Did not find valid JSON inside ${s}`)), Promise.reject()) } catch (n) { return i(new Error(`Error parsing JSON from ${s}: ${n.message}`)), Promise.reject() } } else { let s = "https://storage.googleapis.com/unicornstudio-production"; r || (null == t ? void 0 : t.includes("production=true")) ? (s = "https://assets.unicorn.studio", t = `v=${Date.now()}`) : (null == t ? void 0 : t.includes("update=")) || (t = `v=${Date.now()}`), a = `${s}/embeds/${e}${t ? "?" + t : ""}` } return Promise.resolve(window.__UNICORN_DATA).then(e => e).catch(e => { }) })(t, s, e.filePath, r, e.production).then(s => { s && (s.layers || s.history) && s.options || r(new Error(`Error fetching data for project id '${e.projectId}'`)); const a = s.options || {}, n = (o = e.element, ("object" == typeof HTMLElement ? o instanceof HTMLElement : o && "object" == typeof o && null !== o && 1 === o.nodeType && "string" == typeof o.nodeName) ? e.element : document.getElementById(e.elementId)); var o; if (!n) return void r(new Error(`Couldn't find an element with id '${e.elementId}' on the page.`)); const h = xe(); n.setAttribute("data-scene-id", h); let l = e.scale || a.scale || 1, d = e.dpi || a.dpi || Math.min(1.5, window.devicePixelRatio); const u = function (e, t, s, i) { const r = i ? { ...s, modules: i } : s, a = []; return e.forEach(e => { switch (e.layerType) { case "text": a.push(new He(e, t, null, r).unpackage()); break; case "image": a.push(new We(e, t, r).unpackage()); break; case "model": a.push(new Ne(e, t, r).unpackage()); break; case "shape": a.push(new Ve(e, t, r).unpackage()); break; case "effect": a.push(new Be(e, t, r).unpackage()) } }), a }(s.layers || s.history, h, function (e, t, s) { return { canvasWidth: e.offsetWidth, canvasHeight: e.offsetHeight, scale: t, dpi: s, element: e } }(n, l, d), s.modules), c = new Je({ id: h, fps: e.fps || a.fps || 60, dpi: d, name: a.name, projectId: t || e.filePath.split(".")[0], renderingScale: l, element: n, lazyLoad: e.lazyLoad, fixed: e.fixed, width: e.width, height: e.height }); c.curtain.canvas.innerText = e.altText || "", c.curtain.canvas.setAttribute("aria-label", e.ariaLabel || "Unicorn Studio Scene"), c.curtain.canvas.setAttribute("role", "img"); let p = a[_e("ZnJlZVBsYW4=")]; (p || a[_e("aW5jbHVkZUxvZ28=")]) && function (e, t) { const s = document.createElement("a"); s.href = "#", s.style = "display: none !important; bottom: 30px; left: 0; width: 190px; margin: 0 auto; right: 0rem; padding: 10px; border-radius: 6px; background-color: rgba(255, 255, 255, 1); box-shadow: 0 3px 9px 0 rgba(0, 0, 0, .2); z-index: 99999999; box-sizing: border-box;", s.target = "_blank"; const i = document.createElement("img"); i.src = _e("aHR0cHM6Ly9hc3NldHMudW5pY29ybi5zdHVkaW8vbWVkaWEvbWFkZV9pbl91c19zbWFsbF93ZWIuc3Zn"), i.alt = _e("TWFkZSB3aXRoIHVuaWNvcm4uc3R1ZGlv"), i.style = "display: none;", s.appendChild(i), t.appendChild(s) }(0, n), Qe.push(c), c.layers = u, c.preloadTextures(), c.setInteractiveParams(e, a), c.isInView = c.isFixed || Xe(c.element, c.bbox, 50), c.lazyLoad && !c.isInView || c.initializePlanes(), le || tt(), i(c) }).catch(e => { r(e) }) }) } e.addScene = it, e.destroy = function () { Qe.forEach(e => { e.destroy() }), Qe.length = 0, st() }, e.init = function () { return function () { try { return !!document.createElement("canvas").getContext("webgl2") } catch (e) { return !1 } }() ? new Promise((e, t) => { const s = [...document.querySelectorAll("[data-us-project], [data-us-project-src]")], i = "undefined" != typeof window && window.requestIdleCallback ? window.requestIdleCallback : e => setTimeout(e, 0); s.filter(e => !e.getAttribute("data-us-initialized")).forEach((t, r) => { t.setAttribute("data-us-initialized", !0), i(() => { const i = Te(t, "data-us-project"), a = Te(t, "data-us-project-src"), n = Te(t, "data-us-disablemobile"), o = Te(t, "data-us-disablemouse"); it({ projectId: a ? null : i, filePath: a, element: t, dpi: +Te(t, "data-us-dpi"), scale: +Te(t, "data-us-scale"), production: Te(t, "data-us-production"), fps: +Te(t, "data-us-fps"), lazyLoad: Te(t, "data-us-lazyload"), altText: Te(t, "data-us-alttext"), ariaLabel: Te(t, "data-us-arialabel"), fixed: Te(t, "data-us-fixed"), interactivity: n || o ? { mouse: { disableMobile: n, disabled: o } } : null }).then(t => { r === s.length - 1 && e(Qe) }) }) }) }) : Promise.resolve([]) }, e.scenes = Qe, e.unbindEvents = st, Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }) });

    </script>

    <script>
        window.addEventListener('load', function () {
            if (window.UnicornStudio) {
                UnicornStudio.init();
            }
        });
    </script>
</body>

</html>